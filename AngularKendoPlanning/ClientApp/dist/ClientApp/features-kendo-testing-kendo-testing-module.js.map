{"version":3,"sources":["./node_modules/@progress/kendo-angular-buttons/dist/fesm2015/index.js","./node_modules/@progress/kendo-angular-popup/dist/fesm2015/index.js","./node_modules/@progress/kendo-popup-common/dist/es2015/add-scroll.js","./node_modules/@progress/kendo-popup-common/dist/es2015/align-point.js","./node_modules/@progress/kendo-popup-common/dist/es2015/align.js","./node_modules/@progress/kendo-popup-common/dist/es2015/apply-location-offset.js","./node_modules/@progress/kendo-popup-common/dist/es2015/bounding-offset.js","./node_modules/@progress/kendo-popup-common/dist/es2015/collision.js","./node_modules/@progress/kendo-popup-common/dist/es2015/document.js","./node_modules/@progress/kendo-popup-common/dist/es2015/element-scroll-position.js","./node_modules/@progress/kendo-popup-common/dist/es2015/is-body-offset.js","./node_modules/@progress/kendo-popup-common/dist/es2015/main.js","./node_modules/@progress/kendo-popup-common/dist/es2015/offset-parent-scroll-position.js","./node_modules/@progress/kendo-popup-common/dist/es2015/offset-parent.js","./node_modules/@progress/kendo-popup-common/dist/es2015/offset.js","./node_modules/@progress/kendo-popup-common/dist/es2015/owner-document.js","./node_modules/@progress/kendo-popup-common/dist/es2015/parent-scroll-position.js","./node_modules/@progress/kendo-popup-common/dist/es2015/parents.js","./node_modules/@progress/kendo-popup-common/dist/es2015/position-with-scroll.js","./node_modules/@progress/kendo-popup-common/dist/es2015/position.js","./node_modules/@progress/kendo-popup-common/dist/es2015/remove-scroll.js","./node_modules/@progress/kendo-popup-common/dist/es2015/restrict-to-view.js","./node_modules/@progress/kendo-popup-common/dist/es2015/scroll-position.js","./node_modules/@progress/kendo-popup-common/dist/es2015/scrollbar-width.js","./node_modules/@progress/kendo-popup-common/dist/es2015/sibling-container.js","./node_modules/@progress/kendo-popup-common/dist/es2015/siblings.js","./node_modules/@progress/kendo-popup-common/dist/es2015/window-viewport.js","./node_modules/@progress/kendo-popup-common/dist/es2015/window.js","./src/app/features/kendo-testing/kendo-testing.component.html","./src/app/features/kendo-testing/kendo-testing-routing.module.ts","./src/app/features/kendo-testing/kendo-testing.component.scss","./src/app/features/kendo-testing/kendo-testing.component.ts","./src/app/features/kendo-testing/kendo-testing.module.ts"],"names":[],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACwR;AACtN;AACwC;AAC1B;AACxC;AACO;AAC2B;;AAE1E;AACA;AACA;AACA;AACA;AACA,oCAAoC,oDAAe;AACnD,iCAAiC,4CAAO;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2BAA2B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,MAAM;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,mEAAI,4BAA4B,mEAAI;AACrF;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,YAAY,gFAAS,yBAAyB,gFAAS;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mFAAY;AACnC;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0FAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,0FAAmB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA,oBAAoB,gFAAmB;AACvC;AACA,iCAAiC,wEAAW;AAC5C;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,uDAAS,EAAE;AACvB,KAAK,yCAAyC,OAAO,sDAAQ,EAAE,GAAG;AAClE,KAAK,OAAO,gFAAmB,EAAE;AACjC,KAAK,OAAO,oDAAM;AAClB;AACA;AACA,kBAAkB,OAAO,mDAAK,EAAE;AAChC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,eAAe,OAAO,mDAAK,EAAE;AAC7B,YAAY,OAAO,mDAAK,EAAE;AAC1B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,YAAY,OAAO,mDAAK,EAAE;AAC1B,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,YAAY,OAAO,mDAAK,EAAE;AAC1B,sBAAsB,OAAO,oDAAM,EAAE;AACrC,aAAa,OAAO,oDAAM,EAAE;AAC5B,mBAAmB,OAAO,yDAAW,6BAA6B;AAClE,qBAAqB,OAAO,yDAAW,qCAAqC;AAC5E,oBAAoB,OAAO,yDAAW,8BAA8B;AACpE,cAAc,OAAO,yDAAW,2BAA2B;AAC3D,cAAc,OAAO,yDAAW,2BAA2B;AAC3D,iBAAiB,OAAO,yDAAW,8BAA8B;AACjE,mBAAmB,OAAO,yDAAW,+BAA+B,GAAG,OAAO,yDAAW,mCAAmC;AAC5H,oBAAoB,OAAO,yDAAW,uBAAuB;AAC7D,eAAe,OAAO,0DAAY,oBAAoB;AACtD,cAAc,OAAO,0DAAY,mBAAmB;AACpD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,6BAA6B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC;AACA;AACA,+EAA+E,MAAM;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,gFAAS;AACrB;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,mEAAI;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,8BAA8B,mEAAI;AAClC;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY,+DAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA,oBAAoB,gFAAmB;AACvC;AACA,iCAAiC,wEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,2BAA2B;AAChC,KAAK,OAAO,gFAAmB,EAAE;AACjC,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,gBAAgB,OAAO,mDAAK,uBAAuB;AACnD,iBAAiB,OAAO,mDAAK,wBAAwB;AACrD,aAAa,OAAO,mDAAK,oBAAoB;AAC7C,YAAY,OAAO,mDAAK,EAAE;AAC1B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,gBAAgB,OAAO,oDAAM,EAAE;AAC/B,eAAe,OAAO,6DAAe,4BAA4B;AACjE,oBAAoB,OAAO,yDAAW,mCAAmC;AACzE,qBAAqB,OAAO,yDAAW,qCAAqC;AAC5E,sBAAsB,OAAO,yDAAW,6CAA6C;AACrF,cAAc,OAAO,yDAAW,wCAAwC;AACxE,cAAc,OAAO,yDAAW,wCAAwC;AACxE,iBAAiB,OAAO,yDAAW,2CAA2C;AAC9E,eAAe,OAAO,yDAAW,wBAAwB;AACzD,WAAW,OAAO,yDAAW,uBAAuB;AACpD,oBAAoB,OAAO,yDAAW,iCAAiC;AACvE,oBAAoB,OAAO,yDAAW,0BAA0B;AAChE,uBAAuB,OAAO,yDAAW,4BAA4B;AACrE,eAAe,OAAO,0DAAY,kCAAkC;AACpE,eAAe,OAAO,0DAAY,oBAAoB;AACtD,gBAAgB,OAAO,0DAAY,mCAAmC;AACtE;;AAEA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA,WAAW,yBAAyB;AACpC;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA,aAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA,0BAA0B,4DAAY;AACtC,aAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA;AACA,gBAAgB,UAAU;AAC1B;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,4EAA4E,sBAAsB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,OAAO,yDAAW;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C,8BAA8B,0DAAY;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB;AAChE;AACA,4BAA4B,sDAAsD;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA,YAAY,OAAO,mDAAK,EAAE;AAC1B,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,oBAAoB,OAAO,mDAAK,EAAE;AAClC,mBAAmB,OAAO,oDAAM,EAAE;AAClC,kBAAkB,OAAO,oDAAM,EAAE;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,0DAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,OAAO,wDAAU;AACtB;AACA;AACA,aAAa,OAAO,mDAAK,EAAE;AAC3B,wBAAwB,OAAO,yDAAW,oCAAoC;AAC9E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,OAAO,8DAAgB;AAC5B;AACA;AACA,uBAAuB,OAAO,mDAAK,EAAE;AACrC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA,0BAA0B,4DAAY;AACtC,aAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,sBAAsB,2EAAI;AAC1B;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA,+EAA+E,MAAM;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,qBAAqB,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,iCAAiC,sDAAS,yBAAyB,6DAAM;AACzE;AACA,aAAa;AACb,mEAAmE,6DAAM;AACzE,gDAAgD,kDAAK,+CAA+C,6DAAM;AAC1G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,iCAAiC,kDAAK;AACtC;AACA,oBAAoB,EAAE;AACtB;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,4BAA4B,EAAE;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8BAA8B,4DAAc;;AAE5C;AACA;AACA;AACA;AACA;AACA,4BAA4B,0DAAY;AACxC,wBAAwB,0DAAY;AACpC,yBAAyB,0DAAY;AACrC,yBAAyB,0DAAY;AACrC,8BAA8B,0DAAY;AAC1C,2BAA2B,0DAAY;AACvC,uBAAuB,0DAAY;AACnC,uBAAuB,0DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,mEAAI;AAC/C;AACA;AACA,gDAAgD,mEAAI;AACpD;AACA;AACA;AACA;AACA;AACA,iCAAiC,mEAAI;AACrC;AACA;AACA,iCAAiC,mEAAI;AACrC;AACA;AACA,iCAAiC,mEAAI,oDAAoD,mEAAI;AAC7F;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iCAAiC,mEAAI,sDAAsD,mEAAI;AAC/F;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAI,sBAAsB,mEAAI;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,gCAAgC,OAAO,oDAAM,8BAA8B;AAChF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,uBAAuB,6CAA6C;AACpE,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA,2BAA2B,iCAAiC;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,eAAe;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0DAAY;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA,2BAA2B,0DAAY,GAAG;AAC1C;AACA;AACA;AACA,0BAA0B,0DAAY,GAAG;AACzC;AACA;AACA;AACA;AACA,wBAAwB,0DAAY;AACpC;AACA;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC,sBAAsB,2EAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,oCAAoC;AACpC,mEAAmE;AACnE,oDAAoD;AACpD;AACA;AACA,6CAA6C,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gBAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA,8BAA8B,6BAA6B,EAAE;AAC7D;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAmB;AACvC;AACA,iCAAiC,wEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,0BAA0B;AAC/B,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,oDAAM,EAAE;AACpB,KAAK,OAAO,0EAAY,EAAE;AAC1B,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,gFAAmB;AAC/B;AACA;AACA,YAAY,OAAO,mDAAK,EAAE;AAC1B,YAAY,OAAO,mDAAK,EAAE;AAC1B,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,YAAY,OAAO,mDAAK,EAAE;AAC1B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,qBAAqB,OAAO,mDAAK,EAAE;AACnC,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,YAAY,OAAO,mDAAK,EAAE;AAC1B,mBAAmB,OAAO,mDAAK,EAAE;AACjC,wBAAwB,OAAO,mDAAK,EAAE;AACtC,uBAAuB,OAAO,mDAAK,EAAE;AACrC,mBAAmB,OAAO,oDAAM,EAAE;AAClC,iBAAiB,OAAO,oDAAM,EAAE;AAChC,eAAe,OAAO,oDAAM,oBAAoB;AAChD,cAAc,OAAO,oDAAM,mBAAmB;AAC9C,YAAY,OAAO,oDAAM,EAAE;AAC3B,aAAa,OAAO,oDAAM,EAAE;AAC5B,oBAAoB,OAAO,0DAAY,wCAAwC;AAC/E,cAAc,OAAO,uDAAS,qBAAqB;AACnD,qBAAqB,OAAO,uDAAS,4BAA4B;AACjE,oBAAoB,OAAO,uDAAS,uBAAuB,OAAO,8DAAgB,EAAE,IAAI;AACxF,iBAAiB,OAAO,yDAAW,oCAAoC;AACvE,qBAAqB,OAAO,yDAAW,6BAA6B,GAAG,OAAO,yDAAW,mCAAmC,GAAG,OAAO,yDAAW,mCAAmC;AACpL,WAAW,OAAO,yDAAW,uBAAuB;AACpD,eAAe,OAAO,0DAAY,kCAAkC;AACpE,gBAAgB,OAAO,0DAAY,mCAAmC;AACtE,aAAa,OAAO,0DAAY,gCAAgC;AAChE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA,0BAA0B,4DAAY,EAAE,yEAAW;AACnD,aAAa,IAAI;AACjB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,0DAAY;AACzC;AACA;AACA;AACA;AACA,wBAAwB,0DAAY;AACpC;AACA;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA,2BAA2B,0DAAY,GAAG;AAC1C;AACA;AACA;AACA,0BAA0B,0DAAY,GAAG;AACzC,sBAAsB,2EAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC,oCAAoC;AACpC,mEAAmE;AACnE,oDAAoD;AACpD;AACA;AACA,6CAA6C,gCAAgC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,WAAW;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0FAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,kDAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,0FAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,0FAAmB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA,oBAAoB,gFAAmB;AACvC;AACA,iCAAiC,wEAAW;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,qBAAqB;AAC1B,KAAK,0BAA0B;AAC/B,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,oDAAM,EAAE;AACpB,KAAK,OAAO,0EAAY,EAAE;AAC1B,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,OAAO,gFAAmB;AAC/B;AACA;AACA,YAAY,OAAO,mDAAK,EAAE;AAC1B,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,qBAAqB,OAAO,mDAAK,EAAE;AACnC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,YAAY,OAAO,mDAAK,EAAE;AAC1B,eAAe,OAAO,mDAAK,EAAE;AAC7B,YAAY,OAAO,mDAAK,EAAE;AAC1B,mBAAmB,OAAO,mDAAK,EAAE;AACjC,gBAAgB,OAAO,mDAAK,EAAE;AAC9B,iBAAiB,OAAO,oDAAM,EAAE;AAChC,YAAY,OAAO,oDAAM,EAAE;AAC3B,aAAa,OAAO,oDAAM,EAAE;AAC5B,eAAe,OAAO,oDAAM,oBAAoB;AAChD,cAAc,OAAO,oDAAM,mBAAmB;AAC9C,eAAe,OAAO,yDAAW,oCAAoC;AACrE,qBAAqB,OAAO,yDAAW,6BAA6B,GAAG,OAAO,yDAAW,sCAAsC;AAC/H,WAAW,OAAO,yDAAW,uBAAuB;AACpD,oBAAoB,OAAO,0DAAY,wCAAwC;AAC/E,cAAc,OAAO,uDAAS,qBAAqB;AACnD,kBAAkB,OAAO,uDAAS,yBAAyB;AAC3D,qBAAqB,OAAO,uDAAS,4BAA4B;AACjE,iBAAiB,OAAO,uDAAS,uBAAuB,OAAO,8DAAgB,EAAE,IAAI;AACrF,eAAe,OAAO,0DAAY,kCAAkC;AACpE,gBAAgB,OAAO,0DAAY,mCAAmC;AACtE,aAAa,OAAO,0DAAY,gCAAgC;AAChE,iBAAiB,OAAO,0DAAY,oCAAoC;AACxE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA,0BAA0B,4DAAY,EAAE,yEAAW;AACnD,aAAa,IAAI;AACjB;;AAEA;AACA,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,gBAAgB;AAC3B;AACA;AACA,WAAW,yBAAyB;AACpC;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA,aAAa,IAAI;AACjB;;AAEA;AACA;AACA;;AAEmgB;;;;;;;;;;;;;AC59EngB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACqP;AAC7C;AAC1E;AAChF;AACH;AAC4B;AACxB;;AAE/C;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6BAA6B;AACxC,WAAW,6BAA6B;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,uBAAuB,EAAE,wBAAwB,EAAE,wBAAwB;AACzF;AACA;AACA;AACA,cAAc,gBAAgB,EAAE,iBAAiB,EAAE,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0FAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,0FAAmB;AAC5B;AACA;AACA;AACA;AACA;AACA,oDAAoD,QAAQ,IAAI,GAAG;AACnE;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,oBAAoB,0FAAmB;AACvC;AACA;AACA,oBAAoB,qFAAgB;AACpC;AACA;AACA;AACA,mCAAmC,4EAAO;AAC1C;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,8EAAS;AACxB;AACA;AACA,eAAe,0EAAK;AACpB;AACA;AACA,eAAe,mFAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,yCAAyC;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,wBAAwB;AACvC;AACA,gCAAgC,qBAAqB;AACrD,+BAA+B,oBAAoB;AACnD,8BAA8B,2EAAM;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uFAAkB;AACjC;AACA;AACA,eAAe,iFAAY;AAC3B;AACA;AACA,eAAe,mFAAc;AAC7B;AACA;AACA,eAAe,mFAAc;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,2EAAM;AACrB;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sFAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;;AAEA;AACA;AACA;AACA,8MAA8M,6BAA6B;AAC3O;AACA;AACA;AACA,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ,IAAI;AACJ;AACA;AACA;AACA,kBAAkB,4DAAc;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,sFAAsF;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,aAAa;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,mBAAmB;AACxB,KAAK,6BAA6B,OAAO,oDAAM,kBAAkB,GAAG,OAAO,sDAAQ,EAAE;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kFAAkF;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,mBAAmB;AACxB,KAAK,6BAA6B,OAAO,oDAAM,kBAAkB,GAAG,OAAO,sDAAQ,EAAE;AACrF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA;AACA,gCAAgC,sDAAS;AACzC,sBAAsB,gEAAS;AAC/B;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,mBAAmB;AACxB,KAAK,OAAO,oDAAM;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,0FAAmB;AAC7C;AACA;AACA;AACA;AACA;AACA,oDAAoD,sDAAS,mBAAmB,gEAAS;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,kDAAK;AACrC,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,mBAAmB;AACxB,KAAK,OAAO,oDAAM;AAClB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,MAAM,GAAG,WAAW,6BAA6B;AAChF,cAAc,eAAe,MAAM,GAAG,SAAS;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe,UAAU,GAAG,MAAM,KAAK;AACvD,cAAc,eAAe,UAAU,GAAG,IAAI;AAC9C;AACA;AACA;AACA;AACA,gBAAgB,aAAa;AAC7B,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qBAAqB,MAAM,IAAI;AAC/C,cAAc,qBAAqB,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC,uBAAuB,0DAAY;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,+DAAS;AAC9B,gEAAgE,KAAK;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iEAAK;AACjB,YAAY,mEAAO,IAAI,SAAS,aAAa,iEAAK;AAClD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,OAAO,oEAAgB;AAC5B;;AAEA,wBAAwB;AACxB;AACA;AACA;AACA,0DAA0D,wBAAwB;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,0BAA0B;AACjE;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA,4BAA4B;AAC5B;AACA;AACA,2BAA2B,yCAAyC;AACpE;AACA,0BAA0B;AAC1B;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,oCAAoC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uBAAuB;AAClD;AACA,uCAAuC,0DAAY;AACnD;AACA;AACA;AACA,yBAAyB,0DAAY;AACrC;AACA;AACA;AACA,wBAAwB,0DAAY;AACpC;AACA;AACA;AACA,kCAAkC,0DAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,iDAAI;AAC9C;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,eAAe;AACzD,yCAAyC,cAAc;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0FAAmB;AAChC;AACA;AACA,eAAe,0BAA0B;AACzC;AACA;AACA,gBAAgB,mFAAY;AAC5B,+DAA+D,0BAA0B;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,kCAAkC,mFAAY;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,uDAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,IAAI;AACjB;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB,KAAK,qBAAqB;AAC1B,KAAK,mBAAmB;AACxB,KAAK,wBAAwB;AAC7B,KAAK,sBAAsB;AAC3B,KAAK,0BAA0B;AAC/B,KAAK,yBAAyB;AAC9B,KAAK,OAAO,uDAAS,EAAE;AACvB,KAAK,OAAO,oDAAM;AAClB;AACA;AACA,eAAe,OAAO,mDAAK,EAAE;AAC7B,cAAc,OAAO,mDAAK,EAAE;AAC5B,mBAAmB,OAAO,mDAAK,EAAE;AACjC,iBAAiB,OAAO,mDAAK,EAAE;AAC/B,kBAAkB,OAAO,mDAAK,EAAE;AAChC,wBAAwB,OAAO,mDAAK,EAAE;AACtC,kBAAkB,OAAO,mDAAK,EAAE;AAChC,oBAAoB,OAAO,mDAAK,EAAE;AAClC,cAAc,OAAO,mDAAK,EAAE;AAC5B,cAAc,OAAO,mDAAK,EAAE;AAC5B,2BAA2B,OAAO,oDAAM,EAAE;AAC1C,aAAa,OAAO,oDAAM,EAAE;AAC5B,YAAY,OAAO,oDAAM,EAAE;AAC3B,sBAAsB,OAAO,oDAAM,EAAE;AACrC,wBAAwB,OAAO,uDAAS,wBAAwB;AAChE,oBAAoB,OAAO,uDAAS,SAAS,oFAAqB,IAAI;AACtE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,uBAAuB;AAC9F;AACA;AACA;AACA;AACA;AACA,WAAW,+BAA+B;AAC1C;AACA;AACA,WAAW,yBAAyB;AACpC;AACA,WAAW,uBAAuB;AAClC;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA,QAAQ;AACR,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,4DAAc;AAC1C;AACA;AACA,mBAAmB,uBAAuB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,cAAc;AAC7B,iBAAiB,6BAA6B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,qBAAqB;AACrB,eAAe,mBAAmB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA;AACA,6EAA6E,yDAAW;AACxF;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE;AACjB,iBAAiB;AACjB;AACA;AACA,2CAA2C,yDAAW;AACtD,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,wDAAU,EAAE;AACxB;AACA;AACA;AACA,KAAK,OAAO,4DAAc,EAAE;AAC5B,KAAK,OAAO,sEAAwB,EAAE;AACtC,KAAK,OAAO,sDAAQ,EAAE;AACtB,KAAK,OAAO,wDAAU,gBAAgB,OAAO,oDAAM,4BAA4B,GAAG,OAAO,sDAAQ,EAAE;AACnG;;AAEA;AACA;AACA,+BAA+B,yCAAyC;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,WAAW,yBAAyB;AACpC;AACA,WAAW,WAAW;AACtB;AACA;AACA,WAAW,eAAe;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,OAAO,sDAAQ;AACpB;AACA;AACA;AACA,0BAA0B,4DAAY,EAAE,iFAAkB;AAC1D;AACA,aAAa,IAAI;AACjB;;AAEA;AACA;AACA;;AAE4K;;;;;;;;;;;;;ACtyC5K;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACPF;AAAA;AAAkC;;AAElC;AACA,WAAW,gEAAgE,EAAE;AAC7E;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,2BAA2B,oDAAK;AAChC;AACA;;AAEA,2BAA2B,oDAAK,8BAA8B,oDAAK;AACnE;AACA;;AAEA,4BAA4B,oDAAK;AACjC;AACA;AACA;;AAEA,4BAA4B,oDAAK,+BAA+B,oDAAK;AACrE;AACA;AACA;;AAEA,6BAA6B,oDAAK;AAClC;AACA;;AAEA,6BAA6B,oDAAK,gCAAgC,oDAAK;AACvE;AACA;;AAEA,8BAA8B,oDAAK;AACnC;AACA;AACA;;AAEA,8BAA8B,oDAAK,iCAAiC,oDAAK;AACzE;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEe,oEAAK,EAAC;;;;;;;;;;;;;ACzDrB;AAAA;AAAe;AACf,SAAS,YAAY;;AAErB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAA+C;;AAE/C;AACA;AACA,yBAAyB,gEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,WAAW,2BAA2B;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,6EAAc,EAAC;;;;;;;;;;;;;ACvB9B;AAAe;AACf;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACHF;AAAA;AAA6C;;AAE7C,iCAAiC,+DAAa;;AAE/B,0EAAW,EAAC;;;;;;;;;;;;;ACJ3B;AAAA;AAA+C;;AAEhC;AACf,gDAAgD;AAChD,eAAe,gEAAc;AAC7B;;AAEA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACXF;AAAA;AAA2C;;AAE3C,mCAAmC,8DAAY;;AAEhC,2EAAY,EAAC;;;;;;;;;;;;;ACJ5B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA2C;AACS;AACqB;AACX;AACH;AACD;AACb;AACE;AAC4B;AAC1B;AACsB;AACb;AACK;AACD;AACI;AACjB;;AAEU;AACX;AACiB;;AAEX;AACH;;;;;;;;;;;;;ACtBnD;AAAA;AAAA;AAA8D;AACF;;AAE7C;AACf,0BAA0B,wEAAqB,wBAAwB,uEAAoB;AAC3F,CAAC,EAAC;;;;;;;;;;;;;ACLF;AAAA;AAAyC;;AAEzC;AACA;;AAEA;AACA;AACA;;AAEA,2BAA2B,yDAAe;AAC1C;;AAEe,2EAAY,EAAC;;;;;;;;;;;;;ACZ5B;AAAA;AACA,WAAW,0BAA0B;;AAErC;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS,YAAY;;AAErB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,qEAAM,EAAC;;;;;;;;;;;;;AChCtB;AAAA;AAAe;AACf;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAA2C;AACmB;;AAE/C;AACf,mBAAmB,8DAAY;;AAE/B,oBAAoB,wEAAqB,YAAY;AACrD;;;;;;;;;;;;;ACPA;AAAe;AACf;AACA;;AAEA;AACA;;AAEA,6BAA6B,OAAO;;AAEpC;AACA;;AAEA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACbF;AAAA;AAAA;AAAA;AAAyE;AAC9B;AACT;;AAEnB;AACf,yCAAyC,8DAAY;AACrD,WAAW,2BAA2B,GAAG,yDAAQ;AACjD,WAAW,OAAO,GAAG,8EAA0B;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACjBF;AAAA;AAAA;AAAA;AAA2C;AACT;AACP;;AAE3B;AACA,gBAAgB,uDAAG;AACnB;AACA,mBAAmB,uDAAU;AAC7B,oCAAoC,8DAAY;;AAEhD;AACA;;AAEA,wBAAwB;;AAExB;AACA;;AAEA,uBAAuB,uDAAU;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEe,uEAAQ,EAAC;;;;;;;;;;;;;AC/BxB;AAAA;AAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAuC;AACH;;AAEpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,uBAAuB,sFAAsF;AAC7G;;AAEA,qDAAqD,oDAAU,iCAAiC,oDAAU;AAC1G,kDAAkD,oDAAU,gCAAgC,oDAAU;AACtG,mCAAmC;;AAEnC;AACA,oDAAoD,oDAAU,6BAA6B,oDAAU;AACrG;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA,2BAA2B;AAC3B;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,sFAAsF,EAAE;AACnG,WAAW,iFAAiF;AAC5F,WAAW,+CAA+C;AAC1D;AACA;;AAEA;AACA;;AAEA,uDAAuD,kDAAS;AAChE,mDAAmD,kDAAS;;AAE5D,gCAAgC,kDAAS;AACzC;AACA;;AAEA,kCAAkC,kDAAS;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEe,6EAAc,EAAC;;;;;;;;;;;;;ACzG9B;AAAA;AAAA;AAAA;AAAoC;AACT;;AAEZ;AACf,4BAA4B,yDAAU;AACtC,gBAAgB,uDAAG;;AAEnB;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACXA;AAAA;AAAA;;AAEe;AACf;AACA;;AAEA,6CAA6C,kBAAkB,OAAO,WAAW;AACjF,+BAA+B;AAC/B;;AAEA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;;AAEgC;AACE;;AAEnB;AACf,2BAA2B,wDAAO;AAClC;AACA;AACA;;AAEA;AACA,0BAA0B,yDAAQ;;AAElC;AACA;AACA;AACA;;AAEA,qBAAqB,OAAO;;AAE5B;AACA;;AAEA;AACA,CAAC,EAAC;;;;;;;;;;;;;;ACzBF;AAAe;AACf;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,EAAC;;;;;;;;;;;;;ACbF;AAAA;AAAA;AAAA;AAAA;AAA2B;AACU;AACU;;AAEhC;AACf,gBAAgB,uDAAG;AACnB,qBAAqB,yDAAW;AAChC;AACA;AACA;AACA;;AAEA;AACA,wBAAwB,gEAAc;AACtC;;AAEA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAA6C;;AAE7C,+BAA+B,+DAAa;;AAE7B,wEAAS,EAAC;;;;;;;;;;;;;ACJzB;AAAe,qEAAM,SAAS,uG;;;;;;;;;;;;;;;;;;;ACAW;AACc;AAEW;AAElE,MAAM,MAAM,GAAW,CAAC,EAAE,IAAI,EAAE,EAAE,EAAE,SAAS,EAAE,8EAAqB,EAAE,CAAC,CAAC;AAMxE,IAAa,yBAAyB,GAAtC,MAAa,yBAAyB;CAAI;AAA7B,yBAAyB;IAJrC,8DAAQ,CAAC;QACR,OAAO,EAAE,CAAC,4DAAY,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC;QACxC,OAAO,EAAE,CAAC,4DAAY,CAAC;KACxB,CAAC;GACW,yBAAyB,CAAI;AAAJ;;;;;;;;;;;;;ACXtC;AAAe,6GAA8C,2K;;;;;;;;;;;;;;;;;ACAnB;AAO1C,IAAa,qBAAqB,GAAlC,MAAa,qBAAqB;IALlC;QAMI,UAAK,GAAG,yCAAyC,CAAC;IAKtD,CAAC;IAHG,aAAa;QACT,IAAI,CAAC,KAAK,GAAG,sBAAsB,CAAC;IACxC,CAAC;CACJ;AANY,qBAAqB;IALjC,+DAAS,CAAC;QACT,QAAQ,EAAE,mBAAmB;QAC7B,oPAA6C;;KAE9C,CAAC;GACW,qBAAqB,CAMjC;AANiC;;;;;;;;;;;;;;;;;;;;;;ACPO;AACM;AAE4B;AACT;AACF;AAWhE,IAAa,kBAAkB,GAA/B,MAAa,kBAAkB;CAAI;AAAtB,kBAAkB;IAR9B,8DAAQ,CAAC;QACR,YAAY,EAAE,CAAC,8EAAqB,CAAC;QACrC,OAAO,EAAE;YACL,4DAAY;YACZ,6EAAa;YACb,uFAAyB;SAC5B;KACF,CAAC;GACW,kBAAkB,CAAI;AAAJ","file":"features-kendo-testing-kendo-testing-module.js","sourcesContent":["/**-----------------------------------------------------------------------------------------\n* Copyright © 2019 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { Component, ContentChild, ContentChildren, Directive, ElementRef, EventEmitter, HostBinding, HostListener, Inject, Injectable, InjectionToken, Input, NgModule, NgZone, Optional, Output, Renderer2, TemplateRef, ViewChild, ViewContainerRef, isDevMode } from '@angular/core';\nimport { BehaviorSubject, Subject, fromEvent, merge } from 'rxjs';\nimport { Keys, guid, hasObservers, isChanged, isDocumentAvailable } from '@progress/kendo-angular-common';\nimport { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';\nimport { filter } from 'rxjs/operators';\nimport { CommonModule } from '@angular/common';\nimport { PopupModule, PopupService } from '@progress/kendo-angular-popup';\n\n/**\n * @hidden\n */\nclass KendoButtonService {\n    constructor() {\n        this.buttonLookChange = new BehaviorSubject('default');\n        this.buttonClicked = new Subject();\n        this.buttonClicked$ = this.buttonClicked.asObservable();\n    }\n    click(button) {\n        this.buttonClicked.next(button);\n    }\n    setButtonLook(look) {\n        this.buttonLookChange.next(look);\n    }\n}\nKendoButtonService.decorators = [\n    { type: Injectable },\n];\n\nconst SPAN_TAG_NAME = 'SPAN';\n/**\n * Represents the Kendo UI Button component for Angular.\n */\nclass ButtonDirective {\n    constructor(element, renderer, service, localization, ngZone) {\n        this.service = service;\n        this.ngZone = ngZone;\n        /**\n         * Provides visual styling that indicates if the Button is active.\n         * By default, `toggleable` is set to `false`.\n         */\n        this.toggleable = false;\n        /**\n         * Adds visual weight to the Button and makes it primary.\n         */\n        this.primary = false;\n        /**\n         * Changes the visual appearance by using alternative styling options\n         * ([more information and examples]({% slug appearance_button %})).\n         *\n         * The available values are:\n         * * `flat`\n         * * `outline`\n         */\n        this.look = 'default';\n        /**\n         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabIndex = 0;\n        /**\n         * @hidden\n         */\n        this.role = 'button';\n        /**\n         * Fires each time the selected state of a toggleable button is changed.\n         *\n         * The event argument is the new selected state (boolean).\n         */\n        this.selectedChange = new EventEmitter();\n        /**\n         * Fires each time the user clicks the button.\n         */\n        this.click = new EventEmitter();\n        this.isDisabled = false;\n        this.isIcon = false;\n        this.isIconClass = false;\n        this._focused = false;\n        this.domEvents = [];\n        this.direction = localization.rtl ? 'rtl' : 'ltr';\n        this.localizationChangeSubscription = localization.changes\n            .subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');\n        this.element = element.nativeElement;\n        this.renderer = renderer;\n    }\n    /**\n     * Backwards-compatible alias\n     *\n     * @hidden\n     */\n    get togglable() {\n        return this.toggleable;\n    }\n    /**\n     * @hidden\n     */\n    set togglable(value) {\n        this.toggleable = value;\n    }\n    /**\n     * Sets the selected state of the Button.\n     */\n    get selected() {\n        return this._selected || false;\n    }\n    set selected(value) {\n        this._selected = value;\n    }\n    /**\n     * Defines the name for an existing icon in a Kendo UI theme.\n     * The icon is rendered inside the Button by a `span.k-icon` element.\n     */\n    set icon(icon) {\n        if (icon) {\n            this.iconSetter(icon, () => {\n                this.isIcon = true;\n                const classes = 'k-icon k-i-' + icon;\n                this.addIcon(classes);\n            });\n        }\n        else {\n            this.isIcon = false;\n            this.updateIconNode();\n        }\n    }\n    /**\n     * Defines a CSS class&mdash;or multiple classes separated by spaces&mdash;\n     * which are applied to a `span` element inside the Button. Allows the usage of custom icons.\n     */\n    set iconClass(iconClassName) {\n        if (iconClassName) {\n            this.iconSetter(iconClassName, () => {\n                this.isIconClass = true;\n                this.addIcon(iconClassName);\n            });\n        }\n        else {\n            this.isIconClass = false;\n            this.updateIconNode();\n        }\n    }\n    /**\n     * Defines a URL which is used for an `img` element inside the Button.\n     * The URL can be relative or absolute. If relative, it is evaluated with relation to the web page URL.\n     */\n    set imageUrl(imageUrl) {\n        if (imageUrl) {\n            this.iconSetter(imageUrl, this.addImgIcon.bind(this));\n        }\n        else {\n            this.removeImageNode();\n        }\n    }\n    /**\n     * If set to `true`, it disables the Button.\n     */\n    set disabled(disabled) {\n        this.isDisabled = disabled;\n        this.renderer.setProperty(this.element, 'disabled', disabled);\n    }\n    get disabled() {\n        return this.isDisabled;\n    }\n    set isFocused(isFocused) {\n        this.toggleClass('k-state-focused', isFocused);\n        this._focused = isFocused;\n    }\n    get isFocused() {\n        return this._focused;\n    }\n    get classButton() {\n        return true;\n    }\n    get classDisabled() {\n        return this.isDisabled;\n    }\n    get classPrimary() {\n        return this.primary;\n    }\n    get isFlat() {\n        return this.look === 'flat';\n    }\n    get isBare() {\n        return this.look === 'bare';\n    }\n    get isOutline() {\n        return this.look === 'outline';\n    }\n    get classActive() {\n        return this.selected;\n    }\n    get getDirection() {\n        return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    onFocus() {\n        this.isFocused = true;\n    }\n    /**\n     * @hidden\n     */\n    onBlur() {\n        this.isFocused = false;\n    }\n    ngOnInit() {\n        const isSpan = this.element.tagName === SPAN_TAG_NAME;\n        if (this.service) {\n            this.buttonLookChangeSubscription = this.service.buttonLookChange\n                .pipe(filter((look) => look !== 'default'))\n                .subscribe((look) => this.look = look);\n        }\n        if (!this.element.hasAttribute('role') && this.togglable) {\n            this.toggleAriaCheckbox(this.toggleable);\n        }\n        if (this.role) {\n            this.setAttribute('role', this.role);\n        }\n        this.ngZone.runOutsideAngular(() => {\n            this.domEvents.push(this.renderer.listen(this.element, 'click', this._onButtonClick.bind(this)));\n            this.domEvents.push(this.renderer.listen(this.element, 'keydown', (event) => {\n                if (isSpan && (event.keyCode === Keys.Space || event.keyCode === Keys.Enter)) {\n                    this.click.emit(event);\n                    this._onButtonClick();\n                }\n            }));\n        });\n    }\n    ngOnChanges(change) {\n        if (isChanged('togglable', change) || isChanged('toggleable', change)) {\n            this.toggleAriaCheckbox(this.toggleable);\n        }\n    }\n    ngAfterViewChecked() {\n        this.setIconTextClasses();\n    }\n    ngOnDestroy() {\n        this.imageNode = null;\n        this.iconNode = null;\n        this.renderer = null;\n        this.localizationChangeSubscription.unsubscribe();\n        if (this.service && this.buttonLookChangeSubscription) {\n            this.buttonLookChangeSubscription.unsubscribe();\n        }\n        clearTimeout(this.deferTimeout);\n        this.domEvents.forEach(unbindHandler => unbindHandler());\n    }\n    /**\n     * Focuses the Button component.\n     */\n    focus() {\n        if (isDocumentAvailable()) {\n            this.element.focus();\n            this.isFocused = true;\n        }\n    }\n    /**\n     * Blurs the Button component.\n     */\n    blur() {\n        if (isDocumentAvailable()) {\n            this.element.blur();\n            this.isFocused = false;\n        }\n    }\n    /**\n     * @hidden\n     */\n    setAttribute(attribute, value) {\n        this.renderer.setAttribute(this.element, attribute, value);\n    }\n    /**\n     * @hidden\n     */\n    removeAttribute(attribute) {\n        this.renderer.removeAttribute(this.element, attribute);\n    }\n    /**\n     * @hidden\n     *\n     * Internal setter that triggers selectedChange\n     */\n    setSelected(value) {\n        const changed = this.selected !== value;\n        this.selected = value;\n        this.setAttribute('aria-checked', this.selected.toString());\n        this.toggleClass('k-state-active', this.selected);\n        if (changed && hasObservers(this.selectedChange)) {\n            this.ngZone.run(() => {\n                this.selectedChange.emit(value);\n            });\n        }\n    }\n    toggleAriaCheckbox(shouldSet) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (shouldSet) {\n            this.role = 'checkbox';\n            this.setAttribute('role', this.role);\n            this.setAttribute('aria-checked', this.selected.toString());\n        }\n        else {\n            this.role = 'button';\n            this.setAttribute('role', this.role);\n            this.removeAttribute('aria-checked');\n        }\n    }\n    hasText() {\n        if (isDocumentAvailable()) {\n            return String(this.element.textContent).trim().length > 0;\n        }\n        else {\n            return false;\n        }\n    }\n    addImgIcon(imageUrl) {\n        let renderer = this.renderer;\n        if (this.imageNode) {\n            renderer.setProperty(this.imageNode, 'src', imageUrl);\n        }\n        else if (isDocumentAvailable()) {\n            this.imageNode = renderer.createElement('img');\n            renderer.setProperty(this.imageNode, 'src', imageUrl);\n            renderer.setProperty(this.imageNode, 'className', 'k-image');\n            renderer.setAttribute(this.imageNode, 'role', 'presentation');\n            this.prependChild(this.imageNode);\n        }\n    }\n    addIcon(classNames) {\n        let renderer = this.renderer;\n        if (this.iconNode) {\n            renderer.setProperty(this.iconNode, 'className', classNames);\n        }\n        else if (isDocumentAvailable()) {\n            this.iconNode = renderer.createElement('span');\n            renderer.setProperty(this.iconNode, 'className', classNames);\n            renderer.setAttribute(this.iconNode, 'role', 'presentation');\n            this.prependChild(this.iconNode);\n        }\n    }\n    prependChild(node) {\n        this.defer(() => {\n            if (this.renderer && node !== this.element.firstChild) {\n                this.renderer.insertBefore(this.element, node, this.element.firstChild);\n            }\n        });\n    }\n    defer(callback) {\n        this.ngZone.runOutsideAngular(() => {\n            this.deferTimeout = setTimeout(callback, 0);\n        });\n    }\n    iconSetter(icon, insertIcon) {\n        if (icon) {\n            insertIcon(icon);\n        }\n        this.setIconTextClasses();\n    }\n    removeImageNode() {\n        if (this.imageNode && this.renderer.parentNode(this.imageNode)) {\n            this.renderer.removeChild(this.element, this.imageNode);\n            this.imageNode = null;\n        }\n    }\n    removeIconNode() {\n        if (this.iconNode && this.renderer.parentNode(this.iconNode)) {\n            this.renderer.removeChild(this.element, this.iconNode);\n            this.iconNode = null;\n        }\n    }\n    updateIconNode() {\n        if (!this.isIcon && !this.isIconClass) {\n            this.removeIconNode();\n        }\n    }\n    setIconTextClasses() {\n        const hasIcon = this.isIcon || this.isIconClass || this.imageNode;\n        const hasText = this.hasText();\n        this.toggleClass('k-button-icon', hasIcon && !hasText);\n        this.toggleClass('k-button-icontext', hasIcon && hasText);\n    }\n    toggleClass(className, add) {\n        if (add) {\n            this.renderer.addClass(this.element, className);\n        }\n        else {\n            this.renderer.removeClass(this.element, className);\n        }\n    }\n    _onButtonClick() {\n        if (!this.disabled && this.service) {\n            this.ngZone.run(() => {\n                this.service.click(this);\n            });\n        }\n        if (this.togglable && !this.service) {\n            this.setSelected(!this.selected);\n        }\n    }\n}\nButtonDirective.decorators = [\n    { type: Directive, args: [{\n                exportAs: 'kendoButton',\n                providers: [\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.button'\n                    }\n                ],\n                selector: 'button[kendoButton], span[kendoButton]' // tslint:disable-line\n            },] },\n];\n/** @nocollapse */\nButtonDirective.ctorParameters = () => [\n    { type: ElementRef },\n    { type: Renderer2 },\n    { type: KendoButtonService, decorators: [{ type: Optional }] },\n    { type: LocalizationService },\n    { type: NgZone }\n];\nButtonDirective.propDecorators = {\n    toggleable: [{ type: Input }],\n    togglable: [{ type: Input }],\n    primary: [{ type: Input }],\n    look: [{ type: Input }],\n    selected: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    icon: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    imageUrl: [{ type: Input }],\n    disabled: [{ type: Input }],\n    role: [{ type: Input }],\n    selectedChange: [{ type: Output }],\n    click: [{ type: Output }],\n    classButton: [{ type: HostBinding, args: ['class.k-button',] }],\n    classDisabled: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    classPrimary: [{ type: HostBinding, args: ['class.k-primary',] }],\n    isFlat: [{ type: HostBinding, args: ['class.k-flat',] }],\n    isBare: [{ type: HostBinding, args: ['class.k-bare',] }],\n    isOutline: [{ type: HostBinding, args: ['class.k-outline',] }],\n    classActive: [{ type: HostBinding, args: ['attr.ariaPressed',] }, { type: HostBinding, args: ['class.k-state-active',] }],\n    getDirection: [{ type: HostBinding, args: ['attr.dir',] }],\n    onFocus: [{ type: HostListener, args: ['focus',] }],\n    onBlur: [{ type: HostListener, args: ['blur',] }]\n};\n\n/* tslint:disable:no-null-keyword */\n/* tslint:disable:no-bitwise */\nconst resolvedPromise = Promise.resolve(null);\n/**\n * @hidden\n */\nconst isPresent = (value) => value !== null && value !== undefined;\n/**\n * @hidden\n */\nconst tick = (f) => (resolvedPromise.then(f));\n\n/**\n * @hidden\n */\nclass PreventableEvent {\n    constructor() {\n        this.prevented = false;\n    }\n    /**\n     * Prevents the default action for a specified event.\n     * In this way, the source component suppresses the built-in behavior that follows the event.\n     */\n    preventDefault() {\n        this.prevented = true;\n    }\n    /**\n     * If the event is prevented by any of its subscribers, returns `true`.\n     *\n     * @returns `true` if the default action was prevented. Otherwise, returns `false`.\n     */\n    isDefaultPrevented() {\n        return this.prevented;\n    }\n}\n\n/**\n * @hidden\n */\nconst ariaChecked = 'aria-checked';\n/**\n * @hidden\n */\nconst tabindex = 'tabindex';\n/**\n * Represents the Kendo UI ButtonGroup component for Angular.\n */\nclass ButtonGroupComponent {\n    constructor(service, localization, element) {\n        this.service = service;\n        this.element = element;\n        /**\n         * By default, the selection mode of the ButtonGroup is set to `multiple`.\n         */\n        this.selection = 'multiple';\n        /**\n         * Changes the visual appearance by using alternative styling options\n         * ([more information and examples]({% slug styling_buttongroup %})).\n         * The `look` property of the ButtonGroup takes precedence over the `look` property\n         * of the individual buttons that are part of the group.\n         *\n         * The available values are:\n         * * `flat`\n         * * `outline`\n         */\n        this.look = 'default';\n        /**\n         * Fires every time keyboard navigation occurs.\n         */\n        this.navigate = new EventEmitter();\n        this._tabIndex = 0;\n        this.currentTabIndex = 0;\n        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');\n    }\n    /**\n     * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n     */\n    set tabIndex(value) {\n        this._tabIndex = value;\n        this.currentTabIndex = value;\n    }\n    get tabIndex() {\n        return this._tabIndex;\n    }\n    get wrapperClass() {\n        return true;\n    }\n    get disabledClass() {\n        return this.disabled;\n    }\n    get stretchedClass() {\n        return !!this.width;\n    }\n    get isFlat() {\n        return this.look === 'flat';\n    }\n    get isBare() {\n        return this.look === 'bare';\n    }\n    get isOutline() {\n        return this.look === 'outline';\n    }\n    get getRole() {\n        return this.isSelectionSingle() ? 'radiogroup' : 'group';\n    }\n    get dir() {\n        return this.direction;\n    }\n    get ariaDisabled() {\n        return this.disabled;\n    }\n    get wrapperWidth() {\n        return this.width;\n    }\n    get wrapperTabIndex() {\n        return this.disabled ? undefined : this.currentTabIndex;\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n        if (!this.disabled) {\n            this.navigateFocus(event);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onFocus() {\n        this.currentTabIndex = -1;\n        const focusedIndex = this.buttons.toArray().findIndex(current => current.element.tabIndex !== -1);\n        const index = focusedIndex === -1 ? 0 : focusedIndex;\n        this.focus(this.buttons.filter((_current, i) => {\n            return i === index;\n        }));\n    }\n    /**\n     * @hidden\n     */\n    focusout(event) {\n        if (event.relatedTarget && event.relatedTarget.parentNode !== this.element.nativeElement) {\n            this.defocus(this.buttons.toArray());\n            this.currentTabIndex = this.tabIndex;\n        }\n    }\n    ngOnInit() {\n        this.service.setButtonLook(this.look);\n        this.subscription = this.service.buttonClicked$.subscribe((button) => {\n            let newSelectionValue;\n            if (this.isSelectionSingle()) {\n                newSelectionValue = true;\n                this.deactivate(this.buttons.filter(current => current !== button));\n            }\n            else {\n                this.defocus(this.buttons.toArray());\n                newSelectionValue = !button.selected;\n            }\n            if (button.togglable) {\n                button.setSelected(newSelectionValue);\n                button.setAttribute(ariaChecked, newSelectionValue.toString());\n            }\n            button.setAttribute(tabindex, \"0\");\n        });\n    }\n    ngOnChanges(change) {\n        if (isChanged('disabled', change)) {\n            this.buttons.forEach((button) => {\n                if (isPresent(this.disabled)) {\n                    button.disabled = this.disabled;\n                }\n            });\n        }\n    }\n    ngAfterContentInit() {\n        const isRadioGroup = this.isSelectionSingle();\n        const buttonsRole = isRadioGroup ? 'radio' : 'checkbox';\n        this.buttons.forEach((button) => {\n            if (button.togglable) {\n                button.setAttribute(ariaChecked, button.selected.toString());\n                button.setAttribute('role', buttonsRole);\n            }\n            if (button.selected) {\n                button.setAttribute(tabindex, \"0\");\n            }\n            else {\n                button.setAttribute(tabindex, \"-1\");\n            }\n        });\n    }\n    ngAfterViewChecked() {\n        if (this.buttons.length) {\n            this.buttons.first.renderer.addClass(this.buttons.first.element, 'k-group-start');\n            this.buttons.last.renderer.addClass(this.buttons.last.element, 'k-group-end');\n        }\n    }\n    ngOnDestroy() {\n        this.subscription.unsubscribe();\n        this.localizationChangeSubscription.unsubscribe();\n    }\n    ngAfterContentChecked() {\n        this.verifySettings();\n    }\n    navigateFocus(event) {\n        let focusedIndex = this.buttons.toArray().findIndex(current => current.element.tabIndex !== -1);\n        const firstIndex = 0;\n        const lastIndex = this.buttons.length - 1;\n        const eventArgs = new PreventableEvent();\n        if (event.keyCode === Keys.ArrowRight && focusedIndex < lastIndex) {\n            this.navigate.emit(eventArgs);\n            if (!eventArgs.isDefaultPrevented()) {\n                this.defocus(this.buttons.toArray());\n                this.focus(this.buttons.filter((_current, index) => {\n                    return index === focusedIndex + 1;\n                }));\n            }\n        }\n        if (event.keyCode === Keys.ArrowLeft && focusedIndex > firstIndex) {\n            this.navigate.emit(eventArgs);\n            if (!eventArgs.isDefaultPrevented()) {\n                this.defocus(this.buttons.toArray());\n                this.focus(this.buttons.filter((_current, index) => {\n                    return index === focusedIndex - 1;\n                }));\n            }\n        }\n    }\n    deactivate(buttons) {\n        buttons.forEach((button) => {\n            button.setSelected(false);\n            button.setAttribute(ariaChecked, button.selected.toString());\n            button.setAttribute(tabindex, \"-1\");\n        });\n    }\n    activate(buttons) {\n        buttons.forEach((button) => {\n            button.setSelected(true);\n            button.setAttribute(ariaChecked, button.selected.toString());\n            button.setAttribute(tabindex, \"0\");\n            button.focus();\n        });\n    }\n    defocus(buttons) {\n        buttons.forEach((button) => {\n            button.setAttribute(tabindex, \"-1\");\n        });\n    }\n    focus(buttons) {\n        buttons.forEach((button) => {\n            button.setAttribute(tabindex, \"0\");\n            button.focus();\n        });\n    }\n    verifySettings() {\n        if (isDevMode()) {\n            if (this.isSelectionSingle() && this.buttons.filter(button => button.selected).length > 1) {\n                throw new Error('Having multiple selected buttons with single selection mode is not supported');\n            }\n        }\n    }\n    isSelectionSingle() {\n        return this.selection === 'single';\n    }\n}\nButtonGroupComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoButtonGroup',\n                providers: [\n                    KendoButtonService,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.buttongroup'\n                    }\n                ],\n                selector: 'kendo-buttongroup',\n                template: `\n        <ng-content select=\"[kendoButton]\"></ng-content>\n    `\n            },] },\n];\n/** @nocollapse */\nButtonGroupComponent.ctorParameters = () => [\n    { type: KendoButtonService },\n    { type: LocalizationService },\n    { type: ElementRef }\n];\nButtonGroupComponent.propDecorators = {\n    disabled: [{ type: Input, args: ['disabled',] }],\n    selection: [{ type: Input, args: ['selection',] }],\n    width: [{ type: Input, args: ['width',] }],\n    look: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    navigate: [{ type: Output }],\n    buttons: [{ type: ContentChildren, args: [ButtonDirective,] }],\n    wrapperClass: [{ type: HostBinding, args: ['class.k-button-group',] }],\n    disabledClass: [{ type: HostBinding, args: ['class.k-state-disabled',] }],\n    stretchedClass: [{ type: HostBinding, args: ['class.k-button-group-stretched',] }],\n    isFlat: [{ type: HostBinding, args: ['class.k-button-group-flat',] }],\n    isBare: [{ type: HostBinding, args: ['class.k-button-group-bare',] }],\n    isOutline: [{ type: HostBinding, args: ['class.k-button-group-outline',] }],\n    getRole: [{ type: HostBinding, args: ['attr.role',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    ariaDisabled: [{ type: HostBinding, args: ['attr.aria-disalbed',] }],\n    wrapperWidth: [{ type: HostBinding, args: ['style.width',] }],\n    wrapperTabIndex: [{ type: HostBinding, args: ['attr.tabindex',] }],\n    keydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    onFocus: [{ type: HostListener, args: ['focus',] }],\n    focusout: [{ type: HostListener, args: ['focusout', ['$event'],] }]\n};\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmodules'] }})\n * definition for the Button directive.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Buttons module\n * import { ButtonModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ButtonModule], // import Button module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass ButtonModule {\n}\nButtonModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [ButtonDirective],\n                exports: [ButtonDirective]\n            },] },\n];\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `ButtonGroupComponent`&mdash;The ButtonGroupComponent component class.\n */\nclass ButtonGroupModule {\n}\nButtonGroupModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [ButtonGroupComponent],\n                exports: [ButtonGroupComponent],\n                imports: [CommonModule, ButtonModule]\n            },] },\n];\n\n/* tslint:disable:directive-selector-name */\n/**\n * Used for rendering the list item content.\n *\n * To define the item template, nest a `<ng-template>` tag with the `kendo<ComponentName>ItemTemplate` directive inside the component tag.\n *\n * For the DropDownButton, use the `kendoDropDownButtonItemTemplate` directive.\n * For the SplitButton, use the `kendoSplitButtonItemTemplate` directive.\n *\n * The template context is set to the current component. To get a reference to the current data item, use the `let-dataItem` directive.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-splitbutton [data]=\"listItems\">\n *    <ng-template kendoSplitButtonItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-splitbutton>\n *  <kendo-dropdownbutton [data]=\"listItems\">\n *    <ng-template kendoDropDownButtonItemTemplate let-dataItem>\n *      <span>{{dataItem}} option</span>\n *    </ng-template>\n *  </kendo-dropdownbutton>\n * `\n * })\n * class AppComponent {\n *   public listItems: Array<any> = [{\n *      text: 'item1',\n *      icon: 'refresh',\n *      disabled: false,\n *      click: (dataItem: any) => {\n *          //action\n *      }\n *  }, {\n *      text: 'item2',\n *      icon: 'refresh',\n *      disabled: false,\n *      click: (dataItem: any) => {\n *          //action\n *      }\n *  }]\n * }\n * ```\n *\n * For more examples, refer to the article on the [DropDownList templates]({% slug overview_ddl %}#templates).\n */\nclass ButtonItemTemplateDirective {\n    constructor(templateRef) {\n        this.templateRef = templateRef;\n    }\n}\nButtonItemTemplateDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoDropDownButtonItemTemplate],[kendoSplitButtonItemTemplate]'\n            },] },\n];\n/** @nocollapse */\nButtonItemTemplateDirective.ctorParameters = () => [\n    { type: TemplateRef }\n];\n\n/**\n * @hidden\n */\nclass ListComponent {\n    constructor() {\n        this.onItemClick = new EventEmitter();\n        this.onItemBlur = new EventEmitter();\n    }\n    getText(dataItem) {\n        if (dataItem) {\n            return this.textField ? dataItem[this.textField] : dataItem.text || dataItem;\n        }\n        return undefined;\n    }\n    getIconClasses(dataItem) {\n        const icon = dataItem.icon ? 'k-icon k-i-' + dataItem.icon : undefined;\n        const classes = {};\n        classes[icon || dataItem.iconClass] = true;\n        return classes;\n    }\n    onClick(index) {\n        this.onItemClick.emit(index);\n    }\n    onBlur() {\n        this.onItemBlur.emit();\n    }\n}\nListComponent.decorators = [\n    { type: Component, args: [{\n                selector: 'kendo-button-list',\n                template: `\n        <ul class=\"k-list k-reset\" unselectable=\"on\">\n            <li role=\"menuItem\" unselectable=\"on\" tabindex=\"-1\"\n                kendoButtonFocusable\n                *ngFor=\"let dataItem of data; let index = index;\"\n                [index]=\"index\"\n                [ngClass]=\"{'k-item': true, 'k-state-disabled': dataItem.disabled}\"\n                (click)=\"onClick(index)\"\n                (blur)=\"onBlur()\"\n                [attr.aria-disabled]=\"dataItem.disabled ? true : false\">\n                <ng-template *ngIf=\"itemTemplate?.templateRef\"\n                    [templateContext]=\"{\n                        templateRef: itemTemplate?.templateRef,\n                        $implicit: dataItem\n                    }\">\n                </ng-template>\n                <ng-template [ngIf]=\"!itemTemplate?.templateRef\">\n                    <span\n                        *ngIf=\"dataItem.icon || dataItem.iconClass\"\n                        [ngClass]=\"getIconClasses(dataItem)\"\n                    ></span>\n                    <img\n                        *ngIf=\"dataItem.imageUrl\"\n                        class=\"k-image\"\n                        [src]=\"dataItem.imageUrl\"\n                        alt=\"\"\n                    >\n                    {{ getText(dataItem) }}\n                </ng-template>\n            </li>\n        </ul>\n      `\n            },] },\n];\nListComponent.propDecorators = {\n    data: [{ type: Input }],\n    textField: [{ type: Input }],\n    itemTemplate: [{ type: Input }],\n    onItemClick: [{ type: Output }],\n    onItemBlur: [{ type: Output }]\n};\n\n/**\n * @hidden\n */\nclass FocusService {\n    constructor() {\n        this.onFocus = new EventEmitter();\n    }\n    isFocused(index) {\n        return index === this.focused;\n    }\n    focus(index) {\n        if (this.isFocused(index)) {\n            return;\n        }\n        this.focused = index;\n        this.onFocus.emit(index);\n    }\n    resetFocus() {\n        this.focused = -1;\n    }\n    get focused() {\n        return this.focusedIndex;\n    }\n    set focused(index) {\n        this.focusedIndex = index;\n        this.onFocus.emit(index);\n    }\n}\nFocusService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * @hidden\n */\nclass FocusableDirective {\n    constructor(focusService, elementRef) {\n        this.focusService = focusService;\n        this.element = elementRef.nativeElement;\n        this.subscribeEvents();\n    }\n    get focusedClassName() {\n        return this.focusService.isFocused(this.index);\n    }\n    /**\n     * @hidden\n     */\n    ngOnDestroy() {\n        this.unsubscribeEvents();\n    }\n    subscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.focusSubscription = this.focusService.onFocus.subscribe((index) => {\n            if (this.index === index) {\n                this.element.focus();\n            }\n        });\n    }\n    unsubscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        if (this.focusSubscription) {\n            this.focusSubscription.unsubscribe();\n        }\n    }\n}\nFocusableDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[kendoButtonFocusable]'\n            },] },\n];\n/** @nocollapse */\nFocusableDirective.ctorParameters = () => [\n    { type: FocusService },\n    { type: ElementRef }\n];\nFocusableDirective.propDecorators = {\n    index: [{ type: Input }],\n    focusedClassName: [{ type: HostBinding, args: ['class.k-state-focused',] }]\n};\n\n/**\n * @hidden\n */\nclass TemplateContextDirective {\n    constructor(viewContainerRef) {\n        this.viewContainerRef = viewContainerRef;\n    }\n    set templateContext(context) {\n        if (this.insertedViewRef) {\n            this.viewContainerRef.remove(this.viewContainerRef.indexOf(this.insertedViewRef));\n            this.insertedViewRef = undefined;\n        }\n        if (context.templateRef) {\n            this.insertedViewRef = this.viewContainerRef.createEmbeddedView(context.templateRef, context);\n        }\n    }\n}\nTemplateContextDirective.decorators = [\n    { type: Directive, args: [{\n                selector: '[templateContext]' // tslint:disable-line:directive-selector\n            },] },\n];\n/** @nocollapse */\nTemplateContextDirective.ctorParameters = () => [\n    { type: ViewContainerRef }\n];\nTemplateContextDirective.propDecorators = {\n    templateContext: [{ type: Input }]\n};\n\nconst EXPORTED_DIRECTIVES = [\n    ListComponent,\n    FocusableDirective,\n    ButtonItemTemplateDirective,\n    TemplateContextDirective\n];\n/**\n * @hidden\n */\nclass ListModule {\n}\nListModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [EXPORTED_DIRECTIVES],\n                exports: [EXPORTED_DIRECTIVES],\n                imports: [CommonModule]\n            },] },\n];\n\n/**\n * @hidden\n */\nvar KeyEvents;\n(function (KeyEvents) {\n    KeyEvents[KeyEvents[\"keydown\"] = 0] = \"keydown\";\n    KeyEvents[KeyEvents[\"keypress\"] = 1] = \"keypress\";\n    KeyEvents[KeyEvents[\"keyup\"] = 2] = \"keyup\";\n})(KeyEvents || (KeyEvents = {}));\n\n/**\n * @hidden\n */\nvar NavigationAction;\n(function (NavigationAction) {\n    NavigationAction[NavigationAction[\"Undefined\"] = 0] = \"Undefined\";\n    NavigationAction[NavigationAction[\"Open\"] = 1] = \"Open\";\n    NavigationAction[NavigationAction[\"Close\"] = 2] = \"Close\";\n    NavigationAction[NavigationAction[\"Enter\"] = 3] = \"Enter\";\n    NavigationAction[NavigationAction[\"EnterPress\"] = 4] = \"EnterPress\";\n    NavigationAction[NavigationAction[\"EnterUp\"] = 5] = \"EnterUp\";\n    NavigationAction[NavigationAction[\"Tab\"] = 6] = \"Tab\";\n    NavigationAction[NavigationAction[\"Esc\"] = 7] = \"Esc\";\n    NavigationAction[NavigationAction[\"Navigate\"] = 8] = \"Navigate\";\n})(NavigationAction || (NavigationAction = {}));\n\n/* tslint:disable:deprecation */\n/**\n * @hidden\n */\nclass ListButton {\n    constructor(focusService, navigationService, wrapperRef, _zone, localization) {\n        this.focusService = focusService;\n        this.navigationService = navigationService;\n        this.wrapperRef = wrapperRef;\n        this._zone = _zone;\n        this._open = false;\n        this._disabled = false;\n        this._active = false;\n        this._popupSettings = { animate: true, popupClass: '' };\n        this.listId = guid();\n        this._isFocused = false;\n        this.wrapperBlurred = new EventEmitter();\n        this.focusService = focusService;\n        this.navigationService = navigationService;\n        this.wrapper = wrapperRef.nativeElement;\n        this.localizationChangeSubscription = localization.changes.subscribe(({ rtl }) => this.direction = rtl ? 'rtl' : 'ltr');\n        this.subscribeEvents();\n    }\n    get popupClasses() {\n        var popupClasses = [\n            'k-list-container',\n            'k-reset',\n            'k-group'\n        ];\n        if (this._popupSettings.popupClass) {\n            popupClasses.push(this._popupSettings.popupClass);\n        }\n        return popupClasses.join(' ');\n    }\n    get openState() {\n        return this._open;\n    }\n    set openState(open) {\n        this._open = open;\n    }\n    /**\n     * @hidden\n     */\n    togglePopupVisibility() {\n        if (this._disabled) {\n            return;\n        }\n        this.openState = !this.openState;\n        if (!this.openState) {\n            this.focusService.focus(-1);\n        }\n    }\n    /**\n     * @hidden\n     */\n    onItemClick(index) {\n        this.emitItemClickHandler(index);\n        setTimeout(() => { this.focusWrapper(); }, 1);\n    }\n    ngOnDestroy() {\n        this.openState = false;\n        this.unsubscribeEvents();\n        clearTimeout(this.focusFirstTimeout);\n        clearTimeout(this.blurTimeout);\n        if (this.localizationChangeSubscription) {\n            this.localizationChangeSubscription.unsubscribe();\n        }\n    }\n    subscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.subscribeListItemFocusEvent();\n        this.subscribeComponentBlurredEvent();\n        this.subscribeNavigationEvents();\n    }\n    subscribeListItemFocusEvent() {\n        this.focusSubscription = this.focusService.onFocus.subscribe(() => {\n            this._isFocused = true;\n        });\n    }\n    subscribeComponentBlurredEvent() {\n        this._zone.runOutsideAngular(() => {\n            this.documentClick = fromEvent(document, 'click').pipe(filter((event) => {\n                return !this.wrapperContains(event.target);\n            }));\n            this.tabSubscription = this.navigationService.tab.pipe(filter(() => this._isFocused)).subscribe(this.handleTab.bind(this));\n            this.componentBlurredSubscription = merge(this.documentClick, this.wrapperBlurred).pipe(filter(() => this._isFocused)).subscribe(() => this._zone.run(() => this.blurWrapper()));\n        });\n    }\n    subscribeNavigationEvents() {\n        this.navigationSubscription = this.navigationService.navigate\n            .subscribe(this.focusService.focus.bind(this.focusService));\n        this.enterPressSubscription = this.navigationService.enterpress.subscribe(() => {\n            if (!this._disabled && !this._open) {\n                this._active = true;\n            }\n        });\n        this.enterUpSubscription = this.navigationService.enterup.subscribe(() => {\n            if (!this._open) {\n                this._active = false;\n            }\n            this.enterHandler();\n            this.focusWrapper();\n        });\n        this.openSubscription = this.navigationService.open.subscribe(() => {\n            if (!this._open) {\n                this.togglePopupVisibility();\n                this.focusFirstItem();\n            }\n            else {\n                this.focusWrapper();\n            }\n        });\n        this.closeSubscription = merge(this.navigationService.close, this.navigationService.esc).subscribe(() => this.focusWrapper());\n    }\n    enterHandler() { } // tslint:disable-line\n    unsubscribeEvents() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.unsubscribe(this.componentBlurredSubscription);\n        this.unsubscribe(this.focusSubscription);\n        this.unsubscribe(this.navigationSubscription);\n        this.unsubscribe(this.enterPressSubscription);\n        this.unsubscribe(this.enterUpSubscription);\n        this.unsubscribe(this.openSubscription);\n        this.unsubscribe(this.closeSubscription);\n        this.unsubscribe(this.tabSubscription);\n    }\n    unsubscribe(subscription) {\n        if (subscription) {\n            subscription.unsubscribe();\n        }\n    }\n    /**\n     * @hidden\n     */\n    keyDownHandler(event) {\n        this.keyHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    keyPressHandler(event) {\n        this.keyHandler(event, KeyEvents.keypress);\n    }\n    /**\n     * @hidden\n     */\n    keyUpHandler(event) {\n        this.keyHandler(event, KeyEvents.keyup);\n    }\n    /**\n     * @hidden\n     */\n    keyHandler(event, keyEvent) {\n        if (this._disabled) {\n            return;\n        }\n        let focused = this.focusService.focused || 0;\n        const eventData = event;\n        const action = this.navigationService.process({\n            altKey: eventData.altKey,\n            current: focused,\n            keyCode: eventData.keyCode,\n            keyEvent: keyEvent,\n            max: this._data ? this._data.length - 1 : 0,\n            min: 0\n        });\n        if (action !== NavigationAction.Undefined &&\n            action !== NavigationAction.Tab &&\n            (action !== NavigationAction.Enter || (action === NavigationAction.Enter && this._open))) {\n            eventData.preventDefault();\n        }\n    }\n    emitItemClickHandler(index) {\n        const dataItem = this._data[index];\n        if (this._itemClick) {\n            this._itemClick.emit(dataItem);\n        }\n        if (dataItem && dataItem.click && !dataItem.disabled) {\n            dataItem.click(dataItem);\n        }\n    }\n    focusFirstItem() {\n        if (this._data && isPresent(this._data[0])) {\n            this.focusFirstTimeout = setTimeout(() => { this.focusService.focus(0); }, 1);\n        }\n    }\n    focusWrapper() {\n        if (this._open) {\n            this.togglePopupVisibility();\n            this.focusButton();\n        }\n    }\n    /**\n     * @hidden\n     */\n    blurHandler() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this.blurTimeout = setTimeout(() => {\n            if (!this.wrapperContains(document.activeElement)) {\n                this.blurWrapper();\n            }\n        });\n    }\n    wrapperContains(element) {\n        return this.wrapper === element || this.wrapper.contains(element);\n    }\n    blurWrapper() {\n        if (this._open) {\n            this.togglePopupVisibility();\n        }\n        this._isFocused = false;\n        this._blur.emit();\n    }\n    focusButton() {\n        if (this.button) {\n            this.button.nativeElement.focus();\n        }\n    }\n    handleTab() {\n        this.focusButton();\n        this.blurWrapper();\n    }\n}\n\n/**\n * @hidden\n */\nconst NAVIGATION_CONFIG = new InjectionToken('navigation.config');\n\n/**\n * @hidden\n */\nclass NavigationService {\n    constructor(config) {\n        this.navigate = new EventEmitter();\n        this.open = new EventEmitter();\n        this.close = new EventEmitter();\n        this.enter = new EventEmitter();\n        this.enterpress = new EventEmitter();\n        this.enterup = new EventEmitter();\n        this.tab = new EventEmitter();\n        this.esc = new EventEmitter();\n        this.useLeftRightArrows = config.useLeftRightArrows;\n    }\n    process(args) {\n        const keyCode = args.keyCode;\n        const keyEvent = args.keyEvent;\n        let index;\n        let action = NavigationAction.Undefined;\n        if (keyEvent === KeyEvents.keypress) {\n            if (this.isEnter(keyCode)) {\n                action = NavigationAction.EnterPress;\n            }\n        }\n        else if (keyEvent === KeyEvents.keyup) {\n            if (this.isEnter(keyCode)) {\n                action = NavigationAction.EnterUp;\n            }\n        }\n        else {\n            if (args.altKey && keyCode === Keys.ArrowDown) {\n                action = NavigationAction.Open;\n            }\n            else if (args.altKey && keyCode === Keys.ArrowUp) {\n                action = NavigationAction.Close;\n            }\n            else if (this.isEnter(keyCode)) {\n                action = NavigationAction.Enter;\n            }\n            else if (keyCode === Keys.Escape) {\n                action = NavigationAction.Esc;\n            }\n            else if (keyCode === Keys.Tab) {\n                action = NavigationAction.Tab;\n            }\n            else if (keyCode === Keys.ArrowUp || (this.useLeftRightArrows && keyCode === Keys.ArrowLeft)) {\n                index = this.next({\n                    current: args.current,\n                    start: args.max,\n                    end: args.min,\n                    step: -1\n                });\n                action = NavigationAction.Navigate;\n            }\n            else if (keyCode === Keys.ArrowDown || (this.useLeftRightArrows && keyCode === Keys.ArrowRight)) {\n                index = this.next({\n                    current: args.current,\n                    start: args.min,\n                    end: args.max,\n                    step: 1\n                });\n                action = NavigationAction.Navigate;\n            }\n        }\n        if (action !== NavigationAction.Undefined) {\n            this[NavigationAction[action].toLowerCase()].emit(index);\n        }\n        return action;\n    }\n    isEnter(keyCode) {\n        return keyCode === Keys.Enter || keyCode === Keys.Space;\n    }\n    next(args) {\n        if (!isPresent(args.current)) {\n            return args.start;\n        }\n        else {\n            return args.current !== args.end ? args.current + args.step : args.end;\n        }\n    }\n}\nNavigationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nNavigationService.ctorParameters = () => [\n    { type: undefined, decorators: [{ type: Inject, args: [NAVIGATION_CONFIG,] }] }\n];\n\n/* tslint:disable:no-access-missing-member */\nconst NAVIGATION_SETTINGS = {\n    useLeftRightArrows: true\n};\nconst ɵ0 = NAVIGATION_SETTINGS;\nconst NAVIGATION_SETTINGS_PROVIDER = {\n    provide: NAVIGATION_CONFIG,\n    useValue: ɵ0\n};\n/**\n * Represents the Kendo UI SplitButton component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-splitbutton [data]=\"data\" [icon]=\"'paste'\"\n *      (itemClick)=\"onSplitButtonItemClick($event)\"\n *      (buttonClick)=\"onSplitButtonClick()\">Paste</kendo-splitbutton>\n * `\n * })\n *\n * class AppComponent {\n *   public data: Array<any> = [{\n *       text: 'Keep Text Only',\n *       icon: 'paste-plain-text',\n *       click: () => { console.log('Keep Text Only click handler'); }\n *   }, {\n *       text: 'Paste as HTML',\n *       icon: 'paste-as-html'\n *   }, {\n *       text: 'Paste Markdown',\n *       icon: 'paste-markdown'\n *   }, {\n *       text: 'Set Default Paste'\n *   }];\n *\n *   public onSplitButtonClick(dataItem: any): void {\n *       console.log('Paste');\n *   }\n *\n *   public onSplitButtonItemClick(dataItem: any): void {\n *       if (dataItem) {\n *           console.log(dataItem.text);\n *       }\n *   }\n * }\n * ```\n */\nclass SplitButtonComponent extends ListButton {\n    constructor(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization) {\n        super(focusService, navigationService, wrapperRef, zone, localization);\n        this.popupService = popupService;\n        this.elRef = elRef;\n        /**\n         * Sets the text of the SplitButton.\n         */\n        this.text = '';\n        /**\n         * Defines an icon to be rendered next to the button text\n         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n         */\n        this.icon = '';\n        /**\n         * Defines an icon with a custom CSS class to be rendered next to the button text\n         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n         */\n        this.iconClass = '';\n        /**\n         * Defines the location of an image to be displayed next to the button text\n         * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n         */\n        this.imageUrl = '';\n        /**\n         * Changes the visual appearance by using alternative styling options.\n         *\n         * The available values are:\n         * * `flat`\n         * * `outline`\n         */\n        this.look = 'default';\n        /**\n         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabIndex = 0;\n        /**\n         * Specifies the name of the [font icon]({% slug icons %}#toc-list-of-font-icons) that will\n         * be rendered for the button which opens the popup.\n         */\n        this.arrowButtonIcon = 'arrow-s';\n        /**\n         * Fires each time the user clicks the main button.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         *    selector: 'my-app',\n         *    template: `\n         *        <kendo-splitbutton (buttonClick)=\"onSplitButtonClick()\" [data]=\"data\">\n         *            Reply\n         *        </kendo-splitbutton>\n         *    `\n         * })\n         * class AppComponent {\n         *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];\n         *\n         *    public onSplitButtonClick(): void {\n         *      console.log('SplitButton click');\n         *    }\n         * }\n         * ```\n         *\n         */\n        this.buttonClick = new EventEmitter();\n        /**\n         * Fires each time the user clicks on the drop-down list. The event data contains the data item bound to the clicked list item.\n         *\n         * @example\n         * ```ts\n         * _@Component({\n         *     selector: 'my-app',\n         *    template: `\n         *        <kendo-splitbutton (itemClick)=\"onSplitButtonItemClick($event)\" [data]=\"data\">\n         *          Reply\n         *      </kendo-splitbutton>\n         *    `\n         * })\n         * class AppComponent {\n         *    public data: Array<any> = ['Reply All', 'Forward', 'Reply & Delete'];\n         *\n         *   public onSplitButtonItemClick(dataItem?: string): void {\n         *        if (dataItem) {\n         *            console.log(dataItem);\n         *       }\n         *    }\n         * }\n         * ```\n         *\n         */\n        this.itemClick = new EventEmitter();\n        /**\n         * Fires each time the SplitButton gets focused.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the SplitButton gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel the event, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel the event, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        this.listId = guid();\n        this.buttonText = '';\n        this._itemClick = this.itemClick;\n        this._blur = this.onBlur;\n    }\n    /**\n     * When set to `true`, disables a SplitButton item\n     * ([see example]({% slug databinding_splitbutton %}#toc-arrays-of-complex-data)).\n     */\n    set disabled(value) {\n        this._disabled = value;\n    }\n    get disabled() {\n        return this._disabled;\n    }\n    /**\n     * Configures the popup of the SplitButton.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     * - `align: \"left\" | \"center\" | \"right\"`&mdash;Specifies the alignment of the popup.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({ animate: true, popupClass: '' }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Sets the data of the SplitButton.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n        this._data = data || [];\n    }\n    get data() {\n        if (!this._data) {\n            this.data = [];\n        }\n        return this._data;\n    }\n    /**\n     * @hidden\n     */\n    set openState(open) {\n        if (this.disabled) {\n            return;\n        }\n        const eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        if (eventArgs.isDefaultPrevented()) {\n            return;\n        }\n        this._toggle(open);\n    }\n    /**\n     * @hidden\n     */\n    get openState() {\n        return this._open;\n    }\n    /**\n     * @hidden\n     */\n    get active() {\n        return this._active;\n    }\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n        return this.disabled ? (-1) : this.tabIndex;\n    }\n    set isFocused(value) {\n        this._isFocused = value;\n    }\n    get isFocused() {\n        return this._isFocused && !this._disabled;\n    }\n    get widgetClasses() {\n        return true;\n    }\n    get dir() {\n        return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get ariaLabel() {\n        return `${this.buttonText} splitbutton`;\n    }\n    /**\n     * @hidden\n     */\n    onButtonFocus() {\n        if (!this.isFocused) {\n            this._isFocused = true;\n            this.onFocus.emit();\n        }\n    }\n    /**\n     * @hidden\n     */\n    onButtonClick() {\n        this.buttonClick.emit();\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n        this.keyDownHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    keypress(event) {\n        this.keyPressHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    keyup(event) {\n        this.keyUpHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    ngAfterViewInit() {\n        this.updateButtonText();\n    }\n    /**\n     * @hidden\n     */\n    ngOnChanges(changes) {\n        if (changes.hasOwnProperty('text')) {\n            this.updateButtonText();\n        }\n    }\n    /**\n     * @hidden\n     */\n    togglePopupVisibility() {\n        super.togglePopupVisibility();\n        if (isDocumentAvailable()) {\n            this.button.nativeElement.focus();\n        }\n    }\n    /**\n     * @hidden\n     */\n    wrapperContains(element) {\n        return this.wrapper === element\n            || this.wrapper.contains(element)\n            || (this.popupRef && this.popupRef.popupElement.contains(element));\n    }\n    /**\n     * @hidden\n     */\n    get anchorAlign() {\n        let align = { horizontal: this.popupSettings.align || 'left', vertical: 'bottom' };\n        if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n            align.horizontal = 'right';\n        }\n        return align;\n    }\n    /**\n     * @hidden\n     */\n    get popupAlign() {\n        let align = { horizontal: this.popupSettings.align || 'left', vertical: 'top' };\n        if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n            align.horizontal = 'right';\n        }\n        return align;\n    }\n    /**\n     * Focuses the SplitButton component.\n     */\n    focus() {\n        if (isDocumentAvailable()) {\n            this.button.nativeElement.focus();\n        }\n    }\n    /**\n     * Blurs the SplitButton component.\n     */\n    blur() {\n        if (isDocumentAvailable()) {\n            this.button.nativeElement.blur();\n            this.blurWrapper();\n        }\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this.destroyPopup();\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If the `toggle` method is used to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n        if (this.disabled) {\n            return;\n        }\n        tick(() => (this._toggle((open === undefined) ? !this._open : open)));\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this.openState;\n    }\n    enterHandler() {\n        if (this.disabled) {\n            return;\n        }\n        if (this.openState) {\n            let focused = this.focusService.focused;\n            if (isPresent(focused) && focused !== -1) {\n                this.emitItemClickHandler(focused);\n            }\n        }\n        else {\n            this.buttonClick.emit();\n        }\n    }\n    updateButtonText() {\n        if (isDocumentAvailable()) {\n            let innerText = this.wrapper.innerText.split('\\n').join('').trim();\n            //setTimout is needed because of `Expression has changed after it was checked.` error;\n            setTimeout(() => { this.buttonText = innerText; }, 0);\n        }\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.containerRef : appendTo;\n    }\n    _toggle(open) {\n        this._open = open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    }\n    createPopup() {\n        this.popupRef = this.popupService.open({\n            anchor: this.elRef,\n            anchorAlign: this.anchorAlign,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupAlign: this.popupAlign,\n            popupClass: this.popupClasses\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.openState = false);\n        this.popupRef.popupOpen.subscribe(this.focusFirstItem.bind(this));\n    }\n    destroyPopup() {\n        if (this.popupRef) {\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n}\nSplitButtonComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoSplitButton',\n                providers: [\n                    FocusService,\n                    NavigationService,\n                    NAVIGATION_SETTINGS_PROVIDER,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.splitbutton'\n                    }\n                ],\n                selector: 'kendo-splitbutton',\n                template: `\n        <button kendoButton\n            #button\n            role=\"listbox\"\n            type=\"button\"\n            [look]=\"look\"\n            [tabindex]=\"componentTabIndex\"\n            [disabled]=\"disabled\"\n            [icon]=\"icon\"\n            [class.k-state-active]=\"active\"\n            [iconClass]=\"iconClass\"\n            [imageUrl]=\"imageUrl\"\n            [ngClass]=\"buttonClass\"\n            (focus)=\"onButtonFocus()\"\n            (click)=\"onButtonClick()\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-expanded]=\"openState\"\n            [attr.aria-haspopup]=\"true\"\n            [attr.aria-owns]=\"listId\"\n            [attr.aria-label]=\"ariaLabel\"\n            >\n            {{text}}<ng-content></ng-content>\n        </button>\n        <button kendoButton\n            type=\"button\"\n            [disabled]=\"disabled\"\n            [icon]=\"arrowButtonIcon\"\n            [look]=\"look\"\n            [tabindex]=\"-1\"\n            [ngClass]=\"arrowButtonClass\"\n            (click)=\"togglePopupVisibility()\">\n        </button>\n        <ng-template #popupTemplate>\n            <kendo-button-list\n                [id]=\"listId\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [itemTemplate]=\"itemTemplate\"\n                (onItemBlur)=\"blurHandler()\"\n                (onItemClick)=\"onItemClick($event)\"\n                (keydown)=\"keyDownHandler($event)\"\n                (keypress)=\"keyPressHandler($event)\"\n                (keyup)=\"keyUpHandler($event)\"\n            >\n            </kendo-button-list>\n        </ng-template>\n        <ng-container #container></ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nSplitButtonComponent.ctorParameters = () => [\n    { type: FocusService },\n    { type: NavigationService },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: PopupService },\n    { type: ElementRef },\n    { type: LocalizationService }\n];\nSplitButtonComponent.propDecorators = {\n    text: [{ type: Input }],\n    icon: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    imageUrl: [{ type: Input }],\n    look: [{ type: Input }],\n    disabled: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    textField: [{ type: Input }],\n    data: [{ type: Input }],\n    buttonClass: [{ type: Input }],\n    arrowButtonClass: [{ type: Input }],\n    arrowButtonIcon: [{ type: Input }],\n    buttonClick: [{ type: Output }],\n    itemClick: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    itemTemplate: [{ type: ContentChild, args: [ButtonItemTemplateDirective,] }],\n    button: [{ type: ViewChild, args: ['button',] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    containerRef: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    isFocused: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-split-button',] }, { type: HostBinding, args: ['class.k-button-group',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    keydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    keypress: [{ type: HostListener, args: ['keypress', ['$event'],] }],\n    keyup: [{ type: HostListener, args: ['keyup', ['$event'],] }]\n};\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `SplitButtonComponent`&mdash;The SplitButtonComponent component class.\n */\nclass SplitButtonModule {\n}\nSplitButtonModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [SplitButtonComponent],\n                exports: [SplitButtonComponent, ListModule],\n                imports: [CommonModule, PopupModule, ButtonModule, ListModule]\n            },] },\n];\n\n/* tslint:disable:no-access-missing-member */\nconst NAVIGATION_SETTINGS$1 = {\n    useLeftRightArrows: true\n};\nconst ɵ0$1 = NAVIGATION_SETTINGS$1;\nconst NAVIGATION_SETTINGS_PROVIDER$1 = {\n    provide: NAVIGATION_CONFIG,\n    useValue: ɵ0$1\n};\n/**\n * Represents the Kendo UI DropDownButton component for Angular.\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <kendo-dropdownbutton [data]=\"data\">\n *    User Settings\n *  </kendo-dropdownbutton>\n * `\n * })\n * class AppComponent {\n *   public data: Array<any> = [{\n *       text: 'My Profile'\n *   }, {\n *       text: 'Friend Requests'\n *   }, {\n *       text: 'Account Settings'\n *   }, {\n *       text: 'Support'\n *   }, {\n *       text: 'Log Out'\n *   }];\n * }\n * ```\n */\nclass DropDownButtonComponent extends ListButton {\n    constructor(focusService, navigationService, wrapperRef, zone, popupService, elRef, localization) {\n        super(focusService, navigationService, wrapperRef, zone, localization);\n        this.popupService = popupService;\n        this.elRef = elRef;\n        /**\n         * Defines the name of an existing icon in a Kendo UI theme.\n         */\n        this.icon = '';\n        /**\n         * Defines the list of CSS classes which are used for styling the Button with custom icons.\n         */\n        this.iconClass = '';\n        /**\n         * Defines a URL for styling the button with a custom image.\n         */\n        this.imageUrl = '';\n        /**\n         * Adds visual weight to the default button and makes it primary.\n         */\n        this.primary = false;\n        /**\n         * Changes the visual appearance by using alternative styling options.\n         *\n         * The available values are:\n         * * `flat`\n         * * `outline`\n         */\n        this.look = 'default';\n        /**\n         * Specifies the [`tabIndex`](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex) of the component.\n         */\n        this.tabIndex = 0;\n        /**\n         * Fires each time the user clicks on a drop-down list item. The event data contains the data item bound to the clicked list item.\n         */\n        this.itemClick = new EventEmitter();\n        /**\n         * Fires each time the popup is about to open.\n         * This event is preventable. If you cancel the event, the popup will remain closed.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires each time the popup is about to close.\n         * This event is preventable. If you cancel the event, the popup will remain open.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires each time the DropDownButton gets focused.\n         */\n        this.onFocus = new EventEmitter(); //tslint:disable-line:no-output-rename\n        /**\n         * Fires each time the DropDownButton gets blurred.\n         */\n        this.onBlur = new EventEmitter(); //tslint:disable-line:no-output-rename\n        this.listId = guid();\n        this._itemClick = this.itemClick;\n        this._blur = this.onBlur;\n    }\n    /**\n     * Configures the popup of the DropDownButton.\n     *\n     * The available options are:\n     * - `animate: Boolean`&mdash;Controls the popup animation. By default, the open and close animations are enabled.\n     * - `popupClass: String`&mdash;Specifies a list of CSS classes that are used to style the popup.\n     * - `appendTo: \"root\" | \"component\" | ViewContainerRef`&mdash;Specifies the component to which the popup will be appended.\n     * - `align: \"left\" | \"center\" | \"right\"`&mdash;Specifies the alignment of the popup.\n     */\n    set popupSettings(settings) {\n        this._popupSettings = Object.assign({ animate: true, popupClass: '' }, settings);\n    }\n    get popupSettings() {\n        return this._popupSettings;\n    }\n    /**\n     * Sets the disabled state of the DropDownButton.\n     */\n    set disabled(value) {\n        if (value && this.openState) {\n            this.openState = false;\n        }\n        this._disabled = value;\n    }\n    get disabled() {\n        return this._disabled;\n    }\n    /**\n     * Sets or gets the data of the DropDownButton.\n     *\n     * > The data has to be provided in an array-like list.\n     */\n    set data(data) {\n        this._data = data || [];\n    }\n    get data() {\n        return this._data;\n    }\n    /**\n     * @hidden\n     */\n    set openState(open) {\n        if (this.disabled) {\n            return;\n        }\n        const eventArgs = new PreventableEvent();\n        if (open) {\n            this.open.emit(eventArgs);\n        }\n        else {\n            this.close.emit(eventArgs);\n        }\n        if (eventArgs.isDefaultPrevented()) {\n            return;\n        }\n        this._toggle(open);\n    }\n    /**\n     * @hidden\n     */\n    get openState() {\n        return this._open;\n    }\n    /**\n     * @hidden\n     */\n    get componentTabIndex() {\n        return this.disabled ? (-1) : this.tabIndex;\n    }\n    get appendTo() {\n        const { appendTo } = this.popupSettings;\n        if (!appendTo || appendTo === 'root') {\n            return undefined;\n        }\n        return appendTo === 'component' ? this.container : appendTo;\n    }\n    get focused() {\n        return this._isFocused && !this._disabled;\n    }\n    get widgetClasses() {\n        return true;\n    }\n    get dir() {\n        return this.direction;\n    }\n    /**\n     * @hidden\n     */\n    get active() {\n        return this._active;\n    }\n    /**\n     * @hidden\n     */\n    keydown(event) {\n        this.keyDownHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    keypress(event) {\n        this.keyPressHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    keyup(event) {\n        this.keyUpHandler(event);\n    }\n    /**\n     * @hidden\n     */\n    mousedown(event) {\n        if (this._disabled) {\n            event.preventDefault();\n        }\n    }\n    /**\n     * @hidden\n     */\n    openPopup() {\n        this.togglePopupVisibility();\n    }\n    /**\n     * @hidden\n     */\n    get anchorAlign() {\n        let align = { horizontal: this.popupSettings.align || 'left', vertical: 'bottom' };\n        if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n            align.horizontal = 'right';\n        }\n        return align;\n    }\n    /**\n     * @hidden\n     */\n    get popupAlign() {\n        let align = { horizontal: this.popupSettings.align || 'left', vertical: 'top' };\n        if (this.direction === 'rtl' && !isPresent(this.popupSettings.align)) {\n            align.horizontal = 'right';\n        }\n        return align;\n    }\n    /**\n     * Focuses the DropDownButton component.\n     */\n    focus() {\n        if (isDocumentAvailable()) {\n            this.button.nativeElement.focus();\n        }\n    }\n    /**\n     * Blurs the DropDownButton component.\n     */\n    blur() {\n        if (isDocumentAvailable()) {\n            this.button.nativeElement.blur();\n            this.blurWrapper();\n        }\n    }\n    ngOnDestroy() {\n        super.ngOnDestroy();\n        this.destroyPopup();\n    }\n    /**\n     * Toggles the visibility of the popup.\n     * If the `toggle` method is used to open or close the popup, the `open` and `close` events will not be fired.\n     *\n     * @param open - The state of the popup.\n     */\n    toggle(open) {\n        if (this.disabled) {\n            return;\n        }\n        tick(() => (this._toggle((open === undefined) ? !this._open : open)));\n    }\n    /**\n     * Returns the current open state of the popup.\n     */\n    get isOpen() {\n        return this.openState;\n    }\n    /**\n     * @hidden\n     */\n    handleFocus() {\n        if (!this._disabled && !this._isFocused) {\n            this._isFocused = true;\n            this.onFocus.emit();\n        }\n    }\n    /**\n     * @hidden\n     */\n    wrapperContains(element) {\n        return this.wrapper === element\n            || this.wrapper.contains(element)\n            || (this.popupRef && this.popupRef.popupElement.contains(element));\n    }\n    subscribeNavigationEvents() {\n        this.navigationSubscription = this.navigationService.navigate\n            .subscribe(this.onArrowKeyNavigate.bind(this));\n        this.enterPressSubscription = this.navigationService.enterpress.subscribe(this.onNavigationEnterPress.bind(this));\n        this.enterUpSubscription = this.navigationService.enterup.subscribe(this.onNavigationEnterUp.bind(this));\n        this.openSubscription = this.navigationService.open.subscribe(this.onNavigationOpen.bind(this));\n        this.closeSubscription = merge(this.navigationService.close, this.navigationService.esc).subscribe(this.onNavigationClose.bind(this));\n    }\n    onNavigationEnterPress() {\n        if (!this._disabled && !this.openState) {\n            this._active = true;\n        }\n    }\n    onNavigationEnterUp() {\n        if (!this._disabled && !this.openState) {\n            this._active = false;\n        }\n        if (this.openState) {\n            let focused = this.focusService.focused;\n            if (isPresent(focused) && focused !== -1) {\n                this.emitItemClickHandler(focused);\n            }\n        }\n        this.togglePopupVisibility();\n        if (!this.openState && isDocumentAvailable()) {\n            this.button.nativeElement.focus();\n        }\n    }\n    onNavigationOpen() {\n        if (!this._disabled && !this.openState) {\n            this.togglePopupVisibility();\n        }\n    }\n    onNavigationClose() {\n        if (this.openState) {\n            this.togglePopupVisibility();\n            if (isDocumentAvailable()) {\n                this.button.nativeElement.focus();\n            }\n        }\n    }\n    onArrowKeyNavigate(index) {\n        this.focusService.focus(index);\n    }\n    _toggle(open) {\n        if (this._open === open) {\n            return;\n        }\n        this._open = open;\n        this.destroyPopup();\n        if (this._open) {\n            this.createPopup();\n        }\n    }\n    createPopup() {\n        this.popupRef = this.popupService.open({\n            anchor: this.elRef,\n            anchorAlign: this.anchorAlign,\n            animate: this.popupSettings.animate,\n            appendTo: this.appendTo,\n            content: this.popupTemplate,\n            popupAlign: this.popupAlign,\n            popupClass: this.popupClasses\n        });\n        this.popupRef.popupAnchorViewportLeave.subscribe(() => this.openState = false);\n        this.popupRef.popupOpen.subscribe(this.focusFirstItem.bind(this));\n    }\n    destroyPopup() {\n        if (this.popupRef) {\n            this.popupRef.close();\n            this.popupRef = null;\n        }\n    }\n}\nDropDownButtonComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendoDropDownButton',\n                providers: [\n                    FocusService,\n                    NavigationService,\n                    NAVIGATION_SETTINGS_PROVIDER$1,\n                    LocalizationService,\n                    {\n                        provide: L10N_PREFIX,\n                        useValue: 'kendo.dropdownbutton'\n                    }\n                ],\n                selector: 'kendo-dropdownbutton',\n                template: `\n        <button kendoButton #button\n            role=\"menu\"\n            type=\"button\"\n            [tabindex]=\"componentTabIndex\"\n            [class.k-state-active]=\"active\"\n            [disabled]=\"disabled\"\n            [icon]=\"icon\"\n            [iconClass]=\"iconClass\"\n            [imageUrl]=\"imageUrl\"\n            [ngClass]=\"buttonClass\"\n            (click)=\"openPopup()\"\n            (focus)=\"handleFocus()\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-expanded]=\"openState\"\n            [attr.aria-haspopup]=\"true\"\n            [attr.aria-owns]=\"listId\"\n            [look]=\"look\"\n            [primary]=\"primary\"\n            >\n            <ng-content></ng-content>\n        </button>\n        <ng-template #popupTemplate>\n            <kendo-button-list\n                #buttonList\n                [id]=\"listId\"\n                [data]=\"data\"\n                [textField]=\"textField\"\n                [itemTemplate]=\"itemTemplate\"\n                (onItemClick)=\"onItemClick($event)\"\n                (keydown)=\"keyDownHandler($event)\"\n                (keypress)=\"keyPressHandler($event)\"\n                (keyup)=\"keyUpHandler($event)\"\n            >\n            </kendo-button-list>\n        </ng-template>\n        <ng-container #container></ng-container>\n    `\n            },] },\n];\n/** @nocollapse */\nDropDownButtonComponent.ctorParameters = () => [\n    { type: FocusService },\n    { type: NavigationService },\n    { type: ElementRef },\n    { type: NgZone },\n    { type: PopupService },\n    { type: ElementRef },\n    { type: LocalizationService }\n];\nDropDownButtonComponent.propDecorators = {\n    icon: [{ type: Input }],\n    iconClass: [{ type: Input }],\n    imageUrl: [{ type: Input }],\n    popupSettings: [{ type: Input }],\n    textField: [{ type: Input }],\n    disabled: [{ type: Input }],\n    data: [{ type: Input }],\n    primary: [{ type: Input }],\n    look: [{ type: Input }],\n    buttonClass: [{ type: Input }],\n    tabIndex: [{ type: Input }],\n    itemClick: [{ type: Output }],\n    open: [{ type: Output }],\n    close: [{ type: Output }],\n    onFocus: [{ type: Output, args: ['focus',] }],\n    onBlur: [{ type: Output, args: ['blur',] }],\n    focused: [{ type: HostBinding, args: ['class.k-state-focused',] }],\n    widgetClasses: [{ type: HostBinding, args: ['class.k-widget',] }, { type: HostBinding, args: ['class.k-dropdown-button',] }],\n    dir: [{ type: HostBinding, args: ['attr.dir',] }],\n    itemTemplate: [{ type: ContentChild, args: [ButtonItemTemplateDirective,] }],\n    button: [{ type: ViewChild, args: ['button',] }],\n    buttonList: [{ type: ViewChild, args: ['buttonList',] }],\n    popupTemplate: [{ type: ViewChild, args: ['popupTemplate',] }],\n    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef },] }],\n    keydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],\n    keypress: [{ type: HostListener, args: ['keypress', ['$event'],] }],\n    keyup: [{ type: HostListener, args: ['keyup', ['$event'],] }],\n    mousedown: [{ type: HostListener, args: ['mousedown', ['$event'],] }]\n};\n\n/**\n * @hidden\n *\n * The exported package module.\n *\n * The package exports:\n * - `DropDownButtonComponent`&mdash;The DropDownButtonComponent component class.\n */\nclass DropDownButtonModule {\n}\nDropDownButtonModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [DropDownButtonComponent],\n                exports: [DropDownButtonComponent, ListModule],\n                imports: [CommonModule, PopupModule, ListModule, ButtonModule]\n            },] },\n];\n\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmodules'] }})\n * definition for the Buttons components.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Buttons module\n * import { ButtonsModule } from '@progress/kendo-angular-buttons';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, ButtonsModule], // import Buttons module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass ButtonsModule {\n}\nButtonsModule.decorators = [\n    { type: NgModule, args: [{\n                exports: [ButtonGroupModule, ButtonModule, SplitButtonModule, DropDownButtonModule]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { KendoButtonService, FocusService, FocusableDirective, ButtonItemTemplateDirective, ListButton, ListComponent, ListModule, TemplateContextDirective, NAVIGATION_CONFIG, NavigationService, ButtonDirective, ButtonDirective as Button, ButtonGroupComponent, ButtonGroupComponent as ButtonGroup, ButtonGroupModule, ButtonModule, ButtonsModule, SplitButtonComponent, SplitButtonComponent as SplitButton, SplitButtonModule, DropDownButtonComponent, DropDownButtonComponent as DropDownButton, DropDownButtonModule };\n","/**-----------------------------------------------------------------------------------------\n* Copyright © 2019 Progress Software Corporation. All rights reserved.\n* Licensed under commercial license. See LICENSE.md in the project root for more information\n*-------------------------------------------------------------------------------------------*/\nimport { ApplicationRef, Component, ComponentFactoryResolver, ElementRef, EventEmitter, Inject, Injectable, InjectionToken, Injector, Input, NgModule, NgZone, Optional, Output, Renderer2, TemplateRef, ViewChild, isDevMode } from '@angular/core';\nimport { addScroll, align, boundingOffset, getWindowViewPort, offset, parents, positionWithScroll, removeScroll, restrictToView, scrollPosition, siblingContainer } from '@progress/kendo-popup-common';\nimport { ResizeSensorComponent, ResizeSensorModule, hasObservers, isDocumentAvailable } from '@progress/kendo-angular-common';\nimport { from, fromEvent, merge } from 'rxjs';\nimport { auditTime } from 'rxjs/operators';\nimport { AnimationBuilder, animate, style } from '@angular/animations';\nimport { CommonModule } from '@angular/common';\n\n/**\n * @hidden\n */\nconst eitherRect = (rect, offset$$1) => {\n    if (!rect) {\n        return { height: 0, left: offset$$1.left, top: offset$$1.top, width: 0 };\n    }\n    return rect;\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\nconst removeStackingOffset = (rect, stackingOffset) => {\n    if (!stackingOffset) {\n        return rect;\n    }\n    const result = {\n        height: rect.height,\n        left: rect.left - stackingOffset.left,\n        top: rect.top - stackingOffset.top,\n        width: rect.width\n    };\n    return result;\n};\n/**\n * @hidden\n */\nconst isDifferentOffset = (oldOffset, newOffset) => {\n    const { left: oldLeft, top: oldTop } = oldOffset;\n    const { left: newLeft, top: newTop } = newOffset;\n    return Math.abs(oldLeft - newLeft) >= 1 || Math.abs(oldTop - newTop) >= 1;\n};\n/**\n * @hidden\n */\nconst isWindowAvailable = () => {\n    return typeof window !== 'undefined';\n};\n/**\n * @hidden\n */\n\n/**\n * @hidden\n */\nconst OVERFLOW_REGEXP = /auto|scroll/;\nconst overflowElementStyle = (element) => {\n    return `${element.style.overflow}${element.style.overflowX}${element.style.overflowY}`;\n};\nconst overflowComputedStyle = (element) => {\n    const styles = window.getComputedStyle(element);\n    return `${styles.overflow}${styles.overflowX}${styles.overflowY}`;\n};\nconst overflowStyle = (element) => {\n    return overflowElementStyle(element) || overflowComputedStyle(element);\n};\n/**\n * @hidden\n */\nconst scrollableParents = (element) => {\n    const parentElements = [];\n    if (!isDocumentAvailable() || !isWindowAvailable()) {\n        return parentElements;\n    }\n    let parent = element.parentElement;\n    while (parent) {\n        if (OVERFLOW_REGEXP.test(overflowStyle(parent)) || parent.hasAttribute('data-scrollable')) {\n            parentElements.push(parent);\n        }\n        parent = parent.parentElement;\n    }\n    parentElements.push(window);\n    return parentElements;\n};\n/**\n * @hidden\n */\nconst FRAME_DURATION = 1000 / 60; //1000ms divided by 60fps\nfunction memoize(fun) {\n    let result;\n    let called = false;\n    return (...args) => {\n        if (called) {\n            return result;\n        }\n        result = fun(...args);\n        called = true;\n        return result;\n    };\n}\n/**\n * @hidden\n */\nconst hasRelativeStackingContext = memoize(() => {\n    if (!isDocumentAvailable() && document.body !== null) {\n        return false;\n    }\n    const top = 10;\n    const parent = document.createElement(\"div\");\n    parent.style.transform = \"matrix(10, 0, 0, 10, 0, 0)\";\n    parent.innerHTML = `<div style=\"position: fixed; top: ${top}px;\">child</div>`;\n    document.body.appendChild(parent);\n    const isDifferent = parent.children[0].getBoundingClientRect().top !== top;\n    document.body.removeChild(parent);\n    return isDifferent;\n});\n/**\n * @hidden\n */\nconst zIndex = (anchor, container) => {\n    if (!anchor || !isDocumentAvailable() || !isWindowAvailable()) {\n        return null;\n    }\n    const sibling = siblingContainer(anchor, container);\n    if (!sibling) {\n        return null;\n    }\n    const result = [anchor].concat(parents(anchor, sibling)).reduce((index, p) => {\n        const zIndexStyle = p.style.zIndex || window.getComputedStyle(p).zIndex;\n        const current = parseInt(zIndexStyle, 10);\n        return current > index ? current : index;\n    }, 0);\n    return result ? (result + 1) : null;\n};\n/**\n * @hidden\n */\nconst scaleRect = (rect, scale) => {\n    if (!rect || scale === 1) {\n        return rect;\n    }\n    return {\n        height: rect.height / scale,\n        left: rect.left / scale,\n        top: rect.top / scale,\n        width: rect.width / scale\n    };\n};\n\nconst STYLES = [\n    'font-size',\n    'font-family',\n    'font-stretch',\n    'font-style',\n    'font-weight',\n    'line-height'\n];\n/**\n * @hidden\n */\nclass DOMService {\n    addOffset(current, addition) {\n        return {\n            left: current.left + addition.left,\n            top: current.top + addition.top\n        };\n    }\n    addScroll(rect, scroll) {\n        return addScroll(rect, scroll);\n    }\n    align(settings) {\n        return align(settings);\n    }\n    boundingOffset(el) {\n        return boundingOffset(this.nativeElement(el));\n    }\n    getFontStyles(el) {\n        const window = this.getWindow();\n        if (!window || !el) {\n            return [];\n        }\n        const computedStyles = window.getComputedStyle(this.nativeElement(el));\n        return STYLES.map(font => ({ key: font, value: computedStyles[font] }));\n    }\n    getWindow() {\n        return isWindowAvailable() ? window : null;\n    }\n    hasOffsetParent(el) {\n        if (!el) {\n            return false;\n        }\n        return !!this.nativeElement(el).offsetParent;\n    }\n    offset(el) {\n        if (!el) {\n            return null;\n        }\n        return offset(this.nativeElement(el));\n    }\n    offsetAtPoint(el, currentLocation) {\n        if (!el) {\n            return null;\n        }\n        const element = this.nativeElement(el);\n        const { left, top, transition } = element.style;\n        element.style.transition = 'none';\n        element.style.left = `${currentLocation.left}px`;\n        element.style.top = `${currentLocation.top}px`;\n        const currentOffset = offset(element);\n        element.style.left = left;\n        element.style.top = top;\n        // prevents elements with transition to be animated because of the change\n        // tslint:disable-next-line:no-unused-expression\n        element.offsetHeight;\n        element.style.transition = transition;\n        return currentOffset;\n    }\n    nativeElement(el) {\n        if (!el) {\n            return null;\n        }\n        return el.nativeElement || el;\n    }\n    position(element, popup, scale = 1) {\n        if (!element || !popup) {\n            return null;\n        }\n        return positionWithScroll(this.nativeElement(element), this.nativeElement(popup), scale);\n    }\n    removeScroll(rect, scroll) {\n        return removeScroll(rect, scroll);\n    }\n    restrictToView(settings) {\n        return restrictToView(settings);\n    }\n    scrollPosition(el) {\n        return scrollPosition(this.nativeElement(el));\n    }\n    scrollableParents(el) {\n        return scrollableParents(this.nativeElement(el));\n    }\n    stackingElementOffset(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return null;\n        }\n        return offset(relativeContextElement);\n    }\n    stackingElementScroll(el) {\n        const relativeContextElement = this.getRelativeContextElement(el);\n        if (!relativeContextElement) {\n            return { x: 0, y: 0 };\n        }\n        return {\n            x: relativeContextElement.scrollLeft,\n            y: relativeContextElement.scrollTop\n        };\n    }\n    getRelativeContextElement(el) {\n        if (!el || !hasRelativeStackingContext()) {\n            return null;\n        }\n        let parent = this.nativeElement(el).parentElement;\n        while (parent) {\n            if (window.getComputedStyle(parent).transform !== 'none') {\n                return parent;\n            }\n            parent = parent.parentElement;\n        }\n        return null;\n    }\n    useRelativePosition(el) {\n        return !!this.getRelativeContextElement(el);\n    }\n    windowViewPort(el) {\n        return getWindowViewPort(this.nativeElement(el));\n    }\n    zIndex(anchor, container) {\n        return zIndex(this.nativeElement(anchor), this.nativeElement(container));\n    }\n    zoomLevel() {\n        if (!isDocumentAvailable() || !isWindowAvailable()) {\n            return 1;\n        }\n        return parseFloat((document.documentElement.clientWidth / window.innerWidth).toFixed(2)) || 1;\n    }\n    isZoomed() {\n        return this.zoomLevel() > 1;\n    }\n}\nDOMService.decorators = [\n    { type: Injectable },\n];\n\n/**\n * Used to set the document scale when using a [scale transform](https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/scale).\n *\n * The document or container scale is required to compute the popup position correctly. Detecting the scale is not reliable and must be set by providing a value for SCALE. See [Support for Document Scale]({% slug documentscale_popup %}).\n *\n * > Using this token is not necessary for user-applied browser zoom.\n *\n * {% meta height:300 %}\n * {% embed_file scale/app.component.ts preview %}\n * {% embed_file scale/app.module.ts %}\n * {% embed_file scale/main.ts %}\n * {% endmeta %}\n *\n *\n */\nconst SCALE = new InjectionToken('Popup Document Scale');\n\n/**\n * @hidden\n */\nclass AlignService {\n    constructor(_dom, scale = 1) {\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    alignElement(settings) {\n        const { anchor, element, anchorAlign, elementAlign, margin, offset: offset$$1, positionMode } = settings;\n        const scale = this.scale || 1;\n        const fixedMode = positionMode === 'fixed' || !this._dom.hasOffsetParent(element);\n        const anchorRect = fixedMode ? this.absoluteRect(anchor, element, offset$$1, scale) : this.relativeRect(anchor, element, offset$$1, scale);\n        const elementRect = scaleRect(this._dom.offset(element), scale);\n        const result = this._dom.align({\n            anchorAlign: anchorAlign,\n            anchorRect: anchorRect,\n            elementAlign: elementAlign,\n            elementRect: elementRect,\n            margin\n        });\n        return result;\n    }\n    absoluteRect(anchor, element, offset$$1, scale) {\n        const scrollPos = this.elementScrollPosition(anchor, element);\n        const rect = eitherRect(this._dom.offset(anchor), offset$$1);\n        const stackScale = 2 * scale;\n        const stackScroll = this._dom.stackingElementScroll(element);\n        if (scale !== 1 && stackScroll) {\n            stackScroll.x /= stackScale;\n            stackScroll.y /= stackScale;\n        }\n        const stackOffset = this._dom.stackingElementOffset(element);\n        if (scale !== 1 && stackOffset) {\n            stackOffset.left /= stackScale;\n            stackOffset.top /= stackScale;\n        }\n        return this._dom.removeScroll(this._dom.addScroll(removeStackingOffset(scaleRect(rect, scale), stackOffset), stackScroll), scrollPos);\n    }\n    elementScrollPosition(anchor, element) {\n        return anchor ? { x: 0, y: 0 } : this._dom.scrollPosition(element);\n    }\n    relativeRect(anchor, element, offset$$1, scale) {\n        const rect = eitherRect(this._dom.position(anchor, element, scale), offset$$1);\n        return scaleRect(rect, scale);\n    }\n}\nAlignService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nAlignService.ctorParameters = () => [\n    { type: DOMService },\n    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass PositionService {\n    constructor(_dom, scale = 1) {\n        this._dom = _dom;\n        this.scale = scale;\n    }\n    positionElement(settings) {\n        const { anchor, currentLocation, element, anchorAlign, elementAlign, collisions, margin } = settings;\n        const dom = this._dom;\n        const scale = this.scale || 1;\n        const elementOffset = dom.offsetAtPoint(element, currentLocation);\n        const elementRect = scaleRect(elementOffset, scale);\n        const anchorOffset = scaleRect(dom.offset(anchor), scale);\n        const anchorRect = eitherRect(anchorOffset, currentLocation);\n        const viewPort = settings.viewPort || dom.windowViewPort(element);\n        viewPort.width = viewPort.width / scale;\n        viewPort.height = viewPort.height / scale;\n        const result = dom.restrictToView({\n            anchorAlign,\n            anchorRect,\n            collisions,\n            elementAlign,\n            elementRect,\n            margin,\n            viewPort\n        });\n        const offset$$1 = dom.addOffset(currentLocation, result.offset);\n        return {\n            flip: result.flip,\n            flipped: result.flipped,\n            offset: offset$$1\n        };\n    }\n}\nPositionService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPositionService.ctorParameters = () => [\n    { type: DOMService },\n    { type: Number, decorators: [{ type: Inject, args: [SCALE,] }, { type: Optional }] }\n];\n\n/**\n * @hidden\n */\nclass ResizeService {\n    constructor(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    subscribe(callback) {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        this._zone.runOutsideAngular(() => {\n            this.subscription = fromEvent(this._dom.getWindow(), \"resize\")\n                .pipe(auditTime(FRAME_DURATION))\n                .subscribe(() => callback());\n        });\n    }\n    unsubscribe() {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    }\n    isUnsubscribed() {\n        return this.subscription && this.subscription.closed;\n    }\n}\nResizeService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nResizeService.ctorParameters = () => [\n    { type: DOMService },\n    { type: NgZone }\n];\n\n/**\n * @hidden\n */\nconst THRESHOLD_DIFF = 1;\n/**\n * @hidden\n */\nclass ScrollableService {\n    constructor(_dom, _zone) {\n        this._dom = _dom;\n        this._zone = _zone;\n    }\n    forElement(element) {\n        this.unsubscribe();\n        this.element = element;\n        return this;\n    }\n    subscribe(callback) {\n        if (!callback || !isDocumentAvailable() || !this.element) {\n            return;\n        }\n        const nativeElement = this._dom.nativeElement(this.element);\n        const parents$$1 = this._dom.scrollableParents(this.element);\n        this._zone.runOutsideAngular(() => {\n            const observables = parents$$1.map(p => fromEvent(p, \"scroll\").pipe(auditTime(FRAME_DURATION)));\n            const subscriber = (e) => {\n                const target = e.target;\n                const isParent = parents$$1.filter(p => p === target).length > 0;\n                const isDocument = target === document;\n                const isWindow = target === window;\n                if (isParent || isDocument || isWindow) {\n                    callback(this.isVisible(nativeElement, target));\n                }\n            };\n            this.subscription = merge(...observables).subscribe(subscriber);\n        });\n    }\n    unsubscribe() {\n        if (!this.subscription) {\n            return;\n        }\n        this.subscription.unsubscribe();\n    }\n    isVisible(elem, container) {\n        const elemRect = this._dom.boundingOffset(elem);\n        const containerRect = this._dom.boundingOffset(container);\n        if (THRESHOLD_DIFF < (containerRect.top - elemRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.top - containerRect.bottom)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (elemRect.left - containerRect.right)) {\n            return false;\n        }\n        if (THRESHOLD_DIFF < (containerRect.left - elemRect.right)) {\n            return false;\n        }\n        return true;\n    }\n}\nScrollableService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nScrollableService.ctorParameters = () => [\n    { type: DOMService },\n    { type: NgZone }\n];\n\nconst LEFT = 'left';\nconst RIGHT = 'right';\nconst DOWN = 'down';\nconst UP = 'up';\nconst DEFAULT_TYPE = 'slide';\nconst DEFAULT_DURATION = 100;\nconst animationTypes = {};\n/* tslint:disable:object-literal-sort-keys */\nanimationTypes.expand = (direction) => {\n    const scale = direction === UP || direction === DOWN ? 'scaleY' : 'scaleX';\n    const startScale = 0;\n    const endScale = 1;\n    let origin;\n    if (direction === DOWN) {\n        origin = 'top';\n    }\n    else if (direction === LEFT) {\n        origin = RIGHT;\n    }\n    else if (direction === RIGHT) {\n        origin = LEFT;\n    }\n    else {\n        origin = 'bottom';\n    }\n    return {\n        start: { transform: `${scale}(${startScale})`, transformOrigin: origin },\n        end: { transform: `${scale}(${endScale})` }\n    };\n};\nanimationTypes.slide = (direction) => {\n    const translate = direction === LEFT || direction === RIGHT ? 'translateX' : 'translateY';\n    const start = direction === RIGHT || direction === DOWN ? -100 : 100;\n    const end = 0;\n    return {\n        start: { transform: `${translate}(${start}%)` },\n        end: { transform: `${translate}(${end}%)` }\n    };\n};\nanimationTypes.fade = () => {\n    return {\n        start: { opacity: 0 },\n        end: { opacity: 1 }\n    };\n};\nanimationTypes.zoom = () => {\n    const start = 0;\n    const end = 1;\n    return {\n        start: { transform: `scale(${start})` },\n        end: { transform: `scale(${end})` }\n    };\n};\n/**\n * @hidden\n */\nclass AnimationService {\n    constructor(animationBuilder) {\n        this.animationBuilder = animationBuilder;\n        this.start = new EventEmitter();\n        this.end = new EventEmitter();\n    }\n    play(element, options, flip) {\n        if (!this.flip || this.flip.horizontal !== flip.horizontal ||\n            this.flip.vertical !== flip.vertical) {\n            this.flip = flip;\n            const type = options.type || DEFAULT_TYPE;\n            const statesFn = animationTypes[type];\n            if (statesFn) {\n                const direction = this.getDirection(flip, options);\n                const states = statesFn(direction);\n                this.playStates(element, states, options);\n            }\n            else if (isDevMode()) {\n                throw new Error(`Unsupported animation type: \"${type}\". The supported types are slide, expand, fade and zoom.`);\n            }\n        }\n    }\n    ngOnDestroy() {\n        this.stopPlayer();\n    }\n    playStates(element, states, options) {\n        this.stopPlayer();\n        const duration = options.duration || DEFAULT_DURATION;\n        const factory = this.animationBuilder.build([\n            style(states.start),\n            animate(`${duration}ms ease-in`, style(states.end))\n        ]);\n        const player = this.player = factory.create(element);\n        player.onDone(() => {\n            this.end.emit();\n            this.stopPlayer();\n        });\n        this.start.emit();\n        player.play();\n    }\n    getDirection(flip, options) {\n        let direction = options.direction || DOWN;\n        if (flip.horizontal) {\n            if (direction === LEFT) {\n                direction = RIGHT;\n            }\n            else if (direction === RIGHT) {\n                direction = LEFT;\n            }\n        }\n        if (flip.vertical) {\n            if (direction === DOWN) {\n                direction = UP;\n            }\n            else if (direction === UP) {\n                direction = DOWN;\n            }\n        }\n        return direction;\n    }\n    stopPlayer() {\n        if (this.player) {\n            this.player.destroy();\n            this.player = null;\n        }\n    }\n}\nAnimationService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nAnimationService.ctorParameters = () => [\n    { type: AnimationBuilder }\n];\n\nconst DEFAULT_OFFSET = { left: -10000, top: 0 };\nconst ANIMATION_CONTAINER = 'k-animation-container';\nconst ANIMATION_CONTAINER_FIXED = 'k-animation-container-fixed';\n/**\n * Represents the [Kendo UI Popup component for Angular]({% slug overview_popup %}).\n *\n * @example\n * ```ts\n * _@Component({\n * selector: 'my-app',\n * template: `\n *  <button #anchor (click)=\"show=!show\">Toggle</button>\n *  <kendo-popup *ngIf=\"show\" [anchor]=\"anchor\">\n *      <strong>Popup content!</strong>\n *  </kendo-popup>\n * `\n * })\n * class AppComponent {\n *   public show: boolean = false;\n * }\n * ```\n */\nclass PopupComponent {\n    constructor(container, _alignService, domService, _positionService, _resizeService, _scrollableService, animationService, _renderer, _zone) {\n        this.container = container;\n        this._alignService = _alignService;\n        this.domService = domService;\n        this._positionService = _positionService;\n        this._resizeService = _resizeService;\n        this._scrollableService = _scrollableService;\n        this.animationService = animationService;\n        this._renderer = _renderer;\n        this._zone = _zone;\n        /**\n         * Controls the Popup animation. By default, the opening and closing animations\n         * are enabled ([see example]({% slug animations_popup %})).\n         */\n        this.animate = true;\n        /**\n         * Specifies the anchor pivot point\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.anchorAlign = { horizontal: 'left', vertical: 'bottom' };\n        /**\n         * Configures the collision behavior of the Popup\n         * ([see example]({% slug viewportboundarydetection_popup %})).\n         */\n        this.collision = { horizontal: 'fit', vertical: 'flip' };\n        /**\n         * Specifies the pivot point of the Popup\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-positioning)).\n         */\n        this.popupAlign = { horizontal: 'left', vertical: 'top' };\n        /**\n         * Controls whether the component will copy the `anchor` font styles.\n         */\n        this.copyAnchorStyles = false;\n        /**\n         * Specifies the position mode of the component. By default, the Popup uses fixed positioning.\n         * To make the Popup acquire absolute positioning, set this option to `absolute`.\n         *\n         * > If you need to support mobile browsers with the zoom option,\n         * use the `absolute` positioning of the Popup.\n         *\n         * @example\n         * ```html\n         * <style>\n         *  .parent-content {\n         *     position: relative;\n         *     width: 200px;\n         *     height: 200px;\n         *     overflow: auto;\n         *     margin: 200px auto;\n         *     border: 1px solid red;\n         *  }\n         *  .content {\n         *     position: relative;\n         *     width: 100px;\n         *     height: 100px;\n         *     overflow: auto;\n         *     margin: 300px;\n         *     border: 1px solid blue;\n         *  }\n         *  .anchor {\n         *     position: absolute;\n         *     top: 200px;\n         *     left: 200px;\n         *  }\n         * </style>\n         * ```\n         * ```ts\n         * _@Component({\n         * selector: 'my-app',\n         * template: `\n         *   <div class=\"example-config\">\n         *      Position mode:\n         *      <label><input type=\"radio\" value=\"fixed\" [(ngModel)]=\"mode\" /> Fixed</label>\n         *      <label><input type=\"radio\" value=\"absolute\" [(ngModel)]=\"mode\" /> Absolute</label>\n         *   </div>\n         *   <div class=\"example-config\">\n         *       Append to\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"1\" [(ngModel)]=\"checked\" />\n         *           Root component\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"2\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: red\">Red Container</span>\n         *       </label>\n         *       <label>\n         *           <input type=\"radio\" name=\"place\" [value]=\"3\" [(ngModel)]=\"checked\" />\n         *           <span style=\"color: blue\">Blue Container</span>\n         *       </label>\n         *   </div>\n         *   <div class=\"example\">\n         *     <div class=\"parent-content\" [scrollLeft]=\"250\" [scrollTop]=\"230\">\n         *         <div class=\"content\" [scrollLeft]=\"170\" [scrollTop]=\"165\">\n         *           <button #anchor class=\"anchor\" (click)=\"show = !show\">Toggle</button>\n         *           <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 3\">\n         *             <ul>\n         *                 <li>Item1</li>\n         *                 <li>Item2</li>\n         *                 <li>Item3</li>\n         *             </ul>\n         *           </kendo-popup>\n         *           <span style=\"position: absolute; top: 400px; left: 400px\">Bottom/Right</span>\n         *         </div>\n         *         <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 2\">\n         *           <ul>\n         *               <li>Item1</li>\n         *               <li>Item2</li>\n         *               <li>Item3</li>\n         *           </ul>\n         *         </kendo-popup>\n         *         <span style=\"position: absolute; top: 600px; left: 600px\">Bottom/Right</span>\n         *     </div>\n         *     <kendo-popup [positionMode]=\"mode\" [anchor]=\"anchor\" (anchorViewportLeave)=\"show=false\" *ngIf=\"show && checked === 1\">\n         *       <ul>\n         *           <li>Item1</li>\n         *           <li>Item2</li>\n         *           <li>Item3</li>\n         *       </ul>\n         *     </kendo-popup>\n         *   </div>\n         * `\n         * })\n         * class AppComponent {\n         *   public checked: number = 3;\n         *   public mode: string = 'absolute';\n         *   public show: boolean = true;\n         * }\n         * ```\n         */\n        this.positionMode = 'fixed';\n        /**\n         * Specifies the absolute position of the element\n         * ([see example]({% slug alignmentpositioning_popup %}#toc-aligning-to-absolute-points)).\n         * The Popup opens next to that point. The Popup pivot point is defined by the `popupAlign` configuration option.\n         * The boundary detection is applied by using the window viewport.\n         */\n        this.offset = DEFAULT_OFFSET;\n        /**\n         * Fires when the anchor is scrolled outside the screen boundaries.\n         * ([see example]({% slug closing_popup %}#toc-after-leaving-the-viewport)).\n         */\n        this.anchorViewportLeave = new EventEmitter();\n        /**\n         * Fires after the component is closed.\n         */\n        this.close = new EventEmitter();\n        /**\n         * Fires after the component is opened and the opening animation ends.\n         */\n        this.open = new EventEmitter();\n        /**\n         * Fires after the component is opened and the Popup is positioned.\n         */\n        this.positionChange = new EventEmitter();\n        this.resolvedPromise = Promise.resolve(null);\n        this.initialCheck = true;\n        this._renderer.addClass(container.nativeElement, ANIMATION_CONTAINER);\n        this.updateFixedClass();\n    }\n    ngOnInit() {\n        this.reposition = this.reposition.bind(this);\n        this._resizeService.subscribe(this.reposition);\n        this.animationSubscriptions = this.animationService.start.subscribe(this.onAnimationStart.bind(this));\n        this.animationSubscriptions.add(this.animationService.end.subscribe(this.onAnimationEnd.bind(this)));\n        this._scrollableService.forElement(this.anchor || this.container).subscribe(this.onScroll.bind(this));\n        this.currentOffset = DEFAULT_OFFSET;\n        this.setZIndex();\n        this.copyFontStyles();\n        this.updateFixedClass();\n    }\n    ngOnChanges(changes) {\n        if (changes.copyAnchorStyles) {\n            this.copyFontStyles();\n        }\n        if (changes.positionMode) {\n            this.updateFixedClass();\n        }\n    }\n    ngAfterViewInit() {\n        this.reposition();\n        if (!this.animate) {\n            this.resolvedPromise.then(() => {\n                this.onAnimationEnd();\n            });\n        }\n    }\n    ngAfterViewChecked() {\n        if (this.initialCheck) {\n            this.initialCheck = false;\n            return;\n        }\n        this._zone.runOutsideAngular(() => {\n            // workarounds https://github.com/angular/angular/issues/19094\n            // uses promise because it is executed synchronously after the content is updated\n            // does not use onStable in case the current zone is not the angular one.\n            this.unsubscribeReposition();\n            this.repositionSubscription = from(this.resolvedPromise)\n                .subscribe(this.reposition);\n        });\n    }\n    ngOnDestroy() {\n        this.anchorViewportLeave.complete();\n        this.positionChange.complete();\n        this.close.emit();\n        this.close.complete();\n        this._resizeService.unsubscribe();\n        this._scrollableService.unsubscribe();\n        this.animationSubscriptions.unsubscribe();\n        this.unsubscribeReposition();\n    }\n    /**\n     * @hidden\n     */\n    onResize() {\n        this.reposition();\n    }\n    onAnimationStart() {\n        this._renderer.removeClass(this.container.nativeElement, 'k-animation-container-shown');\n    }\n    onAnimationEnd() {\n        this._renderer.addClass(this.container.nativeElement, 'k-animation-container-shown');\n        this.open.emit();\n        this.open.complete();\n    }\n    get currentOffset() {\n        return this._currentOffset;\n    }\n    set currentOffset(offset$$1) {\n        this.setContainerStyle('left', `${offset$$1.left}px`);\n        this.setContainerStyle('top', `${offset$$1.top}px`);\n        this._currentOffset = offset$$1;\n    }\n    setZIndex() {\n        if (this.anchor) {\n            this.setContainerStyle('z-index', String(this.domService.zIndex(this.anchor, this.container)));\n        }\n    }\n    reposition() {\n        if (!isDocumentAvailable()) {\n            return;\n        }\n        const { flip, offset: offset$$1 } = this.position();\n        if (!this.currentOffset || isDifferentOffset(this.currentOffset, offset$$1)) {\n            this.currentOffset = offset$$1;\n            if (hasObservers(this.positionChange)) {\n                this._zone.run(() => this.positionChange.emit({ offset: offset$$1, flip }));\n            }\n        }\n        if (this.animate) {\n            this.animationService.play(this.contentContainer.nativeElement, this.animate, flip);\n        }\n        this.resizeSensor.acceptSize();\n    }\n    position() {\n        const alignedOffset = this._alignService.alignElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin,\n            offset: this.offset,\n            positionMode: this.positionMode\n        });\n        return this._positionService.positionElement({\n            anchor: this.anchor,\n            anchorAlign: this.anchorAlign,\n            collisions: this.collision,\n            currentLocation: alignedOffset,\n            element: this.container,\n            elementAlign: this.popupAlign,\n            margin: this.margin\n        });\n    }\n    onScroll(isInViewPort) {\n        const hasLeaveObservers = hasObservers(this.anchorViewportLeave);\n        if (isInViewPort || !hasLeaveObservers) {\n            this.reposition();\n        }\n        else if (hasLeaveObservers) {\n            this._zone.run(() => {\n                this.anchorViewportLeave.emit();\n            });\n        }\n    }\n    copyFontStyles() {\n        if (!this.anchor || !this.copyAnchorStyles) {\n            return;\n        }\n        this.domService.getFontStyles(this.anchor)\n            .forEach(s => this.setContainerStyle(s.key, s.value));\n    }\n    updateFixedClass() {\n        const action = this.positionMode === 'fixed' ? 'addClass' : 'removeClass';\n        this._renderer[action](this.container.nativeElement, ANIMATION_CONTAINER_FIXED);\n    }\n    setContainerStyle(name, value) {\n        this._renderer.setStyle(this.container.nativeElement, name, value);\n    }\n    unsubscribeReposition() {\n        if (this.repositionSubscription) {\n            this.repositionSubscription.unsubscribe();\n        }\n    }\n}\nPopupComponent.decorators = [\n    { type: Component, args: [{\n                exportAs: 'kendo-popup',\n                providers: [AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService],\n                selector: 'kendo-popup',\n                template: `\n        <div class=\"k-popup\" [ngClass]=\"popupClass\" #container>\n            <ng-content></ng-content>\n            <ng-template [ngTemplateOutlet]=\"content\" [ngIf]=\"content\"></ng-template>\n            <kendo-resize-sensor [rateLimit]=\"100\" (resize)=\"onResize()\">\n            </kendo-resize-sensor>\n        </div>\n     `\n            },] },\n];\n/** @nocollapse */\nPopupComponent.ctorParameters = () => [\n    { type: ElementRef },\n    { type: AlignService },\n    { type: DOMService },\n    { type: PositionService },\n    { type: ResizeService },\n    { type: ScrollableService },\n    { type: AnimationService },\n    { type: Renderer2 },\n    { type: NgZone }\n];\nPopupComponent.propDecorators = {\n    animate: [{ type: Input }],\n    anchor: [{ type: Input }],\n    anchorAlign: [{ type: Input }],\n    collision: [{ type: Input }],\n    popupAlign: [{ type: Input }],\n    copyAnchorStyles: [{ type: Input }],\n    popupClass: [{ type: Input }],\n    positionMode: [{ type: Input }],\n    offset: [{ type: Input }],\n    margin: [{ type: Input }],\n    anchorViewportLeave: [{ type: Output }],\n    close: [{ type: Output }],\n    open: [{ type: Output }],\n    positionChange: [{ type: Output }],\n    contentContainer: [{ type: ViewChild, args: ['container',] }],\n    resizeSensor: [{ type: ViewChild, args: [ResizeSensorComponent,] }]\n};\n\nconst removeElement = (element) => {\n    if (element && element.parentNode) {\n        element.parentNode.removeChild(element);\n    }\n};\n/**\n * Used to inject the Popup container. If not provided, the first root component of\n * the application is used.\n *\n * > The `POPUP_CONTAINER` can be used only with the [`PopupService`]({% slug service_popup %}) class.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule, POPUP_CONTAINER } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { ElementRef, NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent],\n *     providers: [{\n *       provide: POPUP_CONTAINER,\n *       useFactory: () => {\n *          //return the container ElementRef, where the popup will be injected\n *          return { nativeElement: document.body } as ElementRef;\n *       }\n *     }]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n * ```\n */\nconst POPUP_CONTAINER = new InjectionToken('Popup Container');\n/**\n * A service for opening Popup components dynamically\n * ([see example]({% slug service_popup %})).\n *\n * @export\n * @class PopupService\n */\nclass PopupService {\n    constructor(applicationRef, componentFactoryResolver, injector, container) {\n        this.applicationRef = applicationRef;\n        this.componentFactoryResolver = componentFactoryResolver;\n        this.injector = injector;\n        this.container = container;\n    }\n    /**\n     * Gets the root view container into which the component will be injected.\n     *\n     * @returns {ComponentRef<any>}\n     */\n    get rootViewContainer() {\n        // https://github.com/angular/angular/blob/4.0.x/packages/core/src/application_ref.ts#L571\n        const rootComponents = this.applicationRef.components || [];\n        if (rootComponents[0]) {\n            return rootComponents[0];\n        }\n        throw new Error(`\n            View Container not found! Inject the POPUP_CONTAINER or define a specific ViewContainerRef via the appendTo option.\n            See http://www.telerik.com/kendo-angular-ui/components/popup/api/POPUP_CONTAINER/ for more details.\n        `);\n    }\n    /**\n     * Sets or gets the HTML element of the root component container.\n     *\n     * @returns {HTMLElement}\n     */\n    get rootViewContainerNode() {\n        return this.container ? this.container.nativeElement : this.getComponentRootNode(this.rootViewContainer);\n    }\n    /**\n     * Opens a Popup component. Created Popups are mounted\n     * in the DOM directly in the root application component.\n     *\n     * @param {PopupSettings} options - The options which define the Popup.\n     * @returns {ComponentRef<PopupComponent>} - A reference to the Popup object.\n     *\n     * @example\n     *\n     * ```ts-no-run\n     * _@Component({\n     *   selector: 'my-app',\n     *   template: `\n     *     <ng-template #template>\n     *      Popup content\n     *     </ng-template>\n     *     <button #anchor kendoButton (click)=\"open(anchor, template)\">Open</button>\n     *   `\n     * })\n     * export class AppComponent {\n     *     public popupRef: PopupRef;\n     *\n     *     constructor( private popupService: PopupService ) {}\n     *\n     *     public open(anchor: ElementRef, template: TemplateRef<any>): void {\n     *         if (this.popupRef) {\n     *              this.popupRef.close();\n     *              this.popupRef = null;\n     *              return;\n     *         }\n     *\n     *         this.popupRef = this.popupService.open({\n     *           anchor: anchor,\n     *           content: template\n     *         });\n     *     }\n     * }\n     * ```\n     */\n    open(options = {}) {\n        const { component, nodes } = this.contentFrom(options.content);\n        const popupComponentRef = this.appendPopup(nodes, options.appendTo);\n        const popupInstance = popupComponentRef.instance;\n        this.projectComponentInputs(popupComponentRef, options);\n        popupComponentRef.changeDetectorRef.detectChanges();\n        if (component) {\n            component.changeDetectorRef.detectChanges();\n        }\n        const popupElement = this.getComponentRootNode(popupComponentRef);\n        return {\n            close: () => {\n                if (component) {\n                    component.destroy();\n                }\n                popupComponentRef.destroy();\n                // Angular will not remove the element unless the change detection is triggered\n                removeElement(popupElement);\n            },\n            content: component,\n            popup: popupComponentRef,\n            popupAnchorViewportLeave: popupInstance.anchorViewportLeave,\n            popupClose: popupInstance.close,\n            popupElement: popupElement,\n            popupOpen: popupInstance.open,\n            popupPositionChange: popupInstance.positionChange\n        };\n    }\n    appendPopup(nodes, container) {\n        const popupComponentRef = this.createComponent(PopupComponent, nodes, container);\n        if (!container) {\n            this.rootViewContainerNode.appendChild(this.getComponentRootNode(popupComponentRef));\n        }\n        return popupComponentRef;\n    }\n    /**\n     * Gets the HTML element for a component reference.\n     *\n     * @param {ComponentRef<any>} componentRef\n     * @returns {HTMLElement}\n     */\n    getComponentRootNode(componentRef) {\n        return componentRef.location.nativeElement;\n    }\n    /**\n     * Gets the `ComponentFactory` instance by its type.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    getComponentFactory(componentClass) {\n        return this.componentFactoryResolver.resolveComponentFactory(componentClass);\n    }\n    /**\n     * Creates a component reference from a `Component` type class.\n     *\n     * @param {*} componentClass\n     * @param {*} nodes\n     * @returns {ComponentRef<any>}\n     */\n    createComponent(componentClass, nodes, container) {\n        const factory = this.getComponentFactory(componentClass);\n        if (container) {\n            return container.createComponent(factory, undefined, this.injector, nodes);\n        }\n        else {\n            const component = factory.create(this.injector, nodes);\n            this.applicationRef.attachView(component.hostView);\n            return component;\n        }\n    }\n    /**\n     * Projects the inputs on the component.\n     *\n     * @param {ComponentRef<any>} component\n     * @param {*} options\n     * @returns {ComponentRef<any>}\n     */\n    projectComponentInputs(component, options) {\n        Object.getOwnPropertyNames(options)\n            .filter(prop => prop !== 'content' || options.content instanceof TemplateRef)\n            .map((prop) => {\n            component.instance[prop] = options[prop];\n        });\n        return component;\n    }\n    /**\n     * Gets the component and the nodes to append from the `content` option.\n     *\n     * @param {*} content\n     * @returns {any}\n     */\n    contentFrom(content) {\n        if (!content || content instanceof TemplateRef) {\n            return { component: null, nodes: [[]] };\n        }\n        const component = this.createComponent(content);\n        const nodes = component ? [component.location.nativeElement] : [];\n        return {\n            component: component,\n            nodes: [\n                nodes // <ng-content>\n            ]\n        };\n    }\n}\nPopupService.decorators = [\n    { type: Injectable },\n];\n/** @nocollapse */\nPopupService.ctorParameters = () => [\n    { type: ApplicationRef },\n    { type: ComponentFactoryResolver },\n    { type: Injector },\n    { type: ElementRef, decorators: [{ type: Inject, args: [POPUP_CONTAINER,] }, { type: Optional }] }\n];\n\nconst POPUP_DIRECTIVES = [PopupComponent];\n/**\n * Represents the [NgModule]({{ site.data.urls.angular['ngmoduleapi'] }})\n * definition for the Popup component.\n *\n * @example\n *\n * ```ts-no-run\n * // Import the Popup module\n * import { PopupModule } from '@progress/kendo-angular-popup';\n *\n * // The browser platform with a compiler\n * import { platformBrowserDynamic } from '@angular/platform-browser-dynamic';\n *\n * import { NgModule } from '@angular/core';\n *\n * // Import the app component\n * import { AppComponent } from './app.component';\n *\n * // Define the app module\n * _@NgModule({\n *     declarations: [AppComponent], // declare app component\n *     imports:      [BrowserModule, PopupModule], // import Popup module\n *     bootstrap:    [AppComponent]\n * })\n * export class AppModule {}\n *\n * // Compile and launch the module\n * platformBrowserDynamic().bootstrapModule(AppModule);\n *\n * ```\n */\nclass PopupModule {\n}\nPopupModule.decorators = [\n    { type: NgModule, args: [{\n                declarations: [POPUP_DIRECTIVES],\n                entryComponents: [POPUP_DIRECTIVES],\n                exports: [POPUP_DIRECTIVES],\n                imports: [CommonModule, ResizeSensorModule],\n                providers: [PopupService]\n            },] },\n];\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AlignService, AnimationService, DOMService, PositionService, ResizeService, ScrollableService, PopupService, POPUP_CONTAINER, PopupComponent, PopupModule, SCALE };\n","export default function addScroll(rect, scroll) {\n    return {\n        top: rect.top + scroll.y,\n        left: rect.left + scroll.x,\n        height: rect.height,\n        width: rect.width\n    };\n}\n","export default {\n    \"bottom\": \"bottom\",\n    \"center\": \"center\",\n    \"middle\": \"middle\",\n    \"left\": \"left\",\n    \"right\": \"right\",\n    \"top\": \"top\"\n};\n","import point from './align-point';\n\nconst align = (options) => {\n    const { anchorRect, anchorAlign, elementRect, elementAlign, margin = {} } = options;\n    const anchorHorizontal = anchorAlign.horizontal;\n    const anchorVertical = anchorAlign.vertical;\n    const elementHorizontal = elementAlign.horizontal;\n    const elementVertical = elementAlign.vertical;\n\n    let horizontalMargin = margin.horizontal || 0;\n    let verticalMargin = margin.vertical || 0;\n\n    let top = anchorRect.top;\n    let left = anchorRect.left;\n\n    if (anchorVertical === point.bottom) {\n        top += anchorRect.height;\n    }\n\n    if (anchorVertical === point.center || anchorVertical === point.middle) {\n        top += Math.round(anchorRect.height / 2);\n    }\n\n    if (elementVertical === point.bottom) {\n        top -= elementRect.height;\n        verticalMargin *= -1;\n    }\n\n    if (elementVertical === point.center || elementVertical === point.middle) {\n        top -= Math.round(elementRect.height / 2);\n        verticalMargin *= -1;\n    }\n\n    if (anchorHorizontal === point.right) {\n        left += anchorRect.width;\n    }\n\n    if (anchorHorizontal === point.center || anchorHorizontal === point.middle) {\n        left += Math.round(anchorRect.width / 2);\n    }\n\n    if (elementHorizontal === point.right) {\n        left -= elementRect.width;\n        horizontalMargin *= -1;\n    }\n\n    if (elementHorizontal === point.center || elementHorizontal === point.middle) {\n        left -= Math.round(elementRect.width / 2);\n        horizontalMargin *= -1;\n    }\n\n    return {\n        top: top + verticalMargin,\n        left: left + horizontalMargin\n    };\n};\n\nexport default align;\n","export default function applyLocationOffset(rect, location, isOffsetBody) {\n    let { top, left } = rect;\n\n    if (isOffsetBody) {\n        left = 0;\n        top = 0;\n    }\n\n    return {\n        top: top + location.top,\n        left: left + location.left,\n        height: rect.height,\n        width: rect.width\n    };\n}\n","import windowViewport from './window-viewport';\n\nconst boundingOffset = (element) => {\n    if (!element.getBoundingClientRect) {\n        const viewport = windowViewport(element);\n        return {\n            bottom: viewport.height,\n            left: 0,\n            right: viewport.width,\n            top: 0\n        };\n    }\n\n    const { bottom, left, right, top } = element.getBoundingClientRect();\n\n    return {\n        bottom,\n        left,\n        right,\n        top\n    };\n};\n\nexport default boundingOffset;\n","export default {\n    \"fit\": \"fit\",\n    \"flip\": \"flip\"\n};\n","import ownerDocument from './owner-document';\n\nconst getDocument = (element) => ownerDocument(element).documentElement;\n\nexport default getDocument;\n","import scrollPosition from './scroll-position';\n\nexport default (element) => {\n    if (element === (element.ownerDocument || {}).body) {\n        return scrollPosition(element);\n    }\n\n    return {\n        x: element.scrollLeft,\n        y: element.scrollTop\n    };\n};\n","import offsetParent from './offset-parent';\n\nconst isBodyOffset = (element) => (offsetParent(element) === element.ownerDocument.body);\n\nexport default isBodyOffset;\n","export { default as align } from './align';\nexport { default as addScroll } from './add-scroll';\nexport { default as applyLocationOffset } from './apply-location-offset';\nexport { default as boundingOffset } from './bounding-offset';\nexport { default as isBodyOffset } from './is-body-offset';\nexport { default as offsetParent } from './offset-parent';\nexport { default as offset } from './offset';\nexport { default as parents } from './parents';\nexport { default as parentScrollPosition } from './parent-scroll-position';\nexport { default as position } from './position';\nexport { default as positionWithScroll } from './position-with-scroll';\nexport { default as removeScroll } from './remove-scroll';\nexport { default as restrictToView } from './restrict-to-view';\nexport { default as scrollPosition } from './scroll-position';\nexport { default as siblingContainer } from './sibling-container';\nexport { default as siblings } from './siblings';\n\nexport { default as getDocumentElement } from './document';\nexport { default as getWindow } from './window';\nexport { default as getWindowViewPort } from './window-viewport';\n\nexport { default as AlignPoint } from './align-point';\nexport { default as Collision } from './collision';\n","import elementScrollPosition from './element-scroll-position';\nimport parentScrollPosition from './parent-scroll-position';\n\nexport default (offsetParentElement, element) => ( // eslint-disable-line no-arrow-condition\n    offsetParentElement ? elementScrollPosition(offsetParentElement) : parentScrollPosition(element)\n);\n","import documentElement from './document';\n\nconst offsetParent = (element) => {\n    let offsetParent = element.offsetParent;\n\n    while (offsetParent && offsetParent.style.position === \"static\") {\n        offsetParent = offsetParent.offsetParent;\n    }\n\n    return offsetParent || documentElement(element);\n};\n\nexport default offsetParent;\n","const rectOfHiddenElement = (element) => {\n    const { display, left, position } = element.style;\n\n    element.style.display = '';\n    element.style.left = '-10000px';\n    element.style.position = 'absolute';\n\n    const rect = element.getBoundingClientRect();\n\n    element.style.display = display;\n    element.style.left = left;\n    element.style.position = position;\n\n    return rect;\n};\n\nconst offset = (element) => {\n    let rect = element.getBoundingClientRect();\n    let { left, top } = rect;\n\n    if (!rect.height && !rect.width) {\n        rect = rectOfHiddenElement(element);\n    }\n\n    return {\n        top: top,\n        left: left,\n        height: rect.height,\n        width: rect.width\n    };\n};\n\nexport default offset;\n","export default function ownerDocument(element) {\n    return element.ownerDocument || element.document || element;\n}\n","import offsetParent from './offset-parent';\nimport elementScrollPosition from './element-scroll-position';\n\nexport default function parentScrollPosition(element) {\n    const parent = offsetParent(element);\n\n    return parent ? elementScrollPosition(parent) : { x: 0, y: 0 };\n}\n","export default (element, until) => {\n    const result = [];\n    let next = element.parentNode;\n\n    while (next) {\n        result.push(next);\n\n        if (next === until) { break; }\n\n        next = next.parentNode;\n    }\n\n    return result;\n};\n","import offsetParentScrollPosition from './offset-parent-scroll-position';\nimport offsetParent from './offset-parent';\nimport position from './position';\n\nexport default (element, parent, scale = 1) => {\n    const offsetParentElement = parent ? offsetParent(parent) : null;\n    const { top, left, height, width } = position(element, offsetParentElement);\n    const { x, y } = offsetParentScrollPosition(offsetParentElement, element);\n    const ownerDocument = element.ownerDocument;\n    const positionScale = offsetParentElement === ownerDocument.body || offsetParentElement === ownerDocument.documentElement ? 1 : scale;\n\n    return {\n        top: top + y * positionScale,\n        left: left + x * positionScale,\n        height: height,\n        width: width\n    };\n};\n","import offsetParent from './offset-parent';\nimport offsetRect from './offset';\nimport wnd from './window';\n\nconst position = (element, parent) => {\n    const win = wnd(element);\n    const elementStyles = win.getComputedStyle(element);\n    const offset = offsetRect(element);\n    const parentElement = parent || offsetParent(element);\n\n    const ownerDocument = element.ownerDocument;\n    const useRelative = parentElement !== ownerDocument.body && parentElement !== ownerDocument.documentElement;\n\n    let parentOffset = { top: 0, left: 0 };\n\n    if (elementStyles.position !== \"fixed\" && useRelative) {\n        const parentStyles = win.getComputedStyle(parentElement);\n\n        parentOffset = offsetRect(parentElement);\n        parentOffset.top += parseInt(parentStyles.borderTopWidth, 10);\n        parentOffset.left += parseInt(parentStyles.borderLeftWidth, 10);\n    }\n\n    return {\n        top: offset.top - parentOffset.top,\n        left: offset.left - parentOffset.left,\n        height: offset.height,\n        width: offset.width\n    };\n};\n\nexport default position;\n","export default function removeScroll(rect, scroll) {\n    return {\n        top: rect.top - scroll.y,\n        left: rect.left - scroll.x,\n        height: rect.height,\n        width: rect.width\n    };\n}\n","import alignPoint from './align-point';\nimport collision from './collision';\n\nconst fit = function(position, size, viewPortSize) {\n    let output = 0;\n\n    if (position + size > viewPortSize) {\n        output = viewPortSize - (position + size);\n    }\n\n    if (position < 0) {\n        output = -position;\n    }\n\n    return output;\n};\n\nconst flip = function({ offset, size, anchorSize, viewPortSize, anchorAlignPoint, elementAlignPoint, margin }) {\n    let output = 0;\n\n    const isPositionCentered = elementAlignPoint === alignPoint.center || elementAlignPoint === alignPoint.middle;\n    const isOriginCentered = anchorAlignPoint === alignPoint.center || anchorAlignPoint === alignPoint.middle;\n    const marginToAdd = 2 * margin; //2x to keep margin after flip\n\n    if (elementAlignPoint !== anchorAlignPoint && !isPositionCentered && !isOriginCentered) {\n        const isBeforeAnchor = anchorAlignPoint === alignPoint.top || anchorAlignPoint === alignPoint.left;\n        if (offset < 0 && isBeforeAnchor) {\n            output = size + anchorSize + marginToAdd;\n            if (offset + output + size > viewPortSize) {\n                output = 0; //skip flip\n            }\n        } else if (offset >= 0 && !isBeforeAnchor) {\n            if (offset + size > viewPortSize) {\n                output += -(anchorSize + size + marginToAdd);\n            }\n\n            if (offset + output < 0) {\n                output = 0; //skip flip\n            }\n        }\n    }\n\n    return output;\n};\n\nconst restrictToView = (options) => {\n    const { anchorRect, anchorAlign, elementRect, elementAlign, collisions, viewPort, margin = {} } = options;\n    const { top: elementTop, left: elementLeft, height: elementHeight, width: elementWidth } = elementRect;\n    const { height: viewPortHeight, width: viewPortWidth } = viewPort;\n    const horizontalMargin = margin.horizontal || 0;\n    const verticalMargin = margin.vertical || 0;\n\n    let left = 0;\n    let top = 0;\n\n    const isHorizontalFlip = collisions.horizontal === collision.flip;\n    const isVerticalFlip = collisions.vertical === collision.flip;\n\n    if (collisions.vertical === collision.fit) {\n        top += fit(elementTop, elementHeight, viewPortHeight);\n    }\n\n    if (collisions.horizontal === collision.fit) {\n        left += fit(elementLeft, elementWidth, viewPortWidth);\n    }\n\n    if (isVerticalFlip) {\n        top += flip({\n            margin: verticalMargin,\n            offset: elementTop,\n            size: elementHeight,\n            anchorSize: anchorRect.height,\n            viewPortSize: viewPortHeight,\n            anchorAlignPoint: anchorAlign.vertical,\n            elementAlignPoint: elementAlign.vertical\n        });\n    }\n\n    if (isHorizontalFlip) {\n        left += flip({\n            margin: horizontalMargin,\n            offset: elementLeft,\n            size: elementWidth,\n            anchorSize: anchorRect.width,\n            viewPortSize: viewPortWidth,\n            anchorAlignPoint: anchorAlign.horizontal,\n            elementAlignPoint: elementAlign.horizontal\n        });\n    }\n    const flippedHorizontal = isHorizontalFlip && left !== 0;\n    const flippedVertical = isVerticalFlip && top !== 0;\n\n    return {\n        flipped: flippedHorizontal || flippedVertical,\n        flip: {\n            horizontal: flippedHorizontal,\n            vertical: flippedVertical\n        },\n        offset: {\n            left: left,\n            top: top\n        }\n    };\n};\n\nexport default restrictToView;\n","import docElement from './document';\nimport wnd from './window';\n\nexport default function scrollPosition(element) {\n    const documentElement = docElement(element);\n    const win = wnd(element);\n\n    return {\n        x: win.pageXOffset || documentElement.scrollLeft || 0,\n        y: win.pageYOffset || documentElement.scrollTop || 0\n    };\n}\n","let cachedWidth = 0;\n\nexport default function scrollbarWidth() {\n    if (!cachedWidth && typeof document !== 'undefined') {\n        const div = document.createElement(\"div\");\n\n        div.style.cssText = \"overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block\";\n        div.innerHTML = \"&nbsp;\";\n        document.body.appendChild(div);\n\n        cachedWidth = div.offsetWidth - div.scrollWidth;\n\n        document.body.removeChild(div);\n    }\n\n    return cachedWidth;\n}\n","/* eslint-disable no-loop-func */\n\nimport parents from './parents';\nimport siblings from './siblings';\n\nexport default (anchor, container) => {\n    const parentElements = parents(anchor);\n    let containerElement = container;\n    let siblingElements;\n    let result;\n\n    while (containerElement) {\n        siblingElements = siblings(containerElement);\n\n        result = parentElements.reduce(\n            (list, p) => list.concat(siblingElements.filter(s => s === p)),\n            []\n        )[0];\n\n        if (result) { break; }\n\n        containerElement = containerElement.parentElement;\n    }\n\n    return result;\n};\n\n","export default (element) => {\n    const result = [];\n\n    let sibling = element.parentNode.firstElementChild;\n\n    while (sibling) {\n        if (sibling !== element) {\n            result.push(sibling);\n        }\n\n        sibling = sibling.nextElementSibling;\n    }\n    return result;\n};\n","import wnd from './window';\nimport getDocument from './document';\nimport scrollbarWidth from './scrollbar-width';\n\nexport default function windowViewport(element) {\n    const win = wnd(element);\n    const document = getDocument(element);\n    const result = {\n        height: win.innerHeight,\n        width: win.innerWidth\n    };\n\n    if (document.scrollHeight - document.clientHeight > 0) {\n        result.width -= scrollbarWidth();\n    }\n\n    return result;\n}\n","import ownerDocument from './owner-document';\n\nconst getWindow = (element) => ownerDocument(element).defaultView;\n\nexport default getWindow;\n","export default \"<p>{{ title }}</p>\\n<button kendoButton (click)=\\\"onButtonClick()\\\" [primary]=\\\"true\\\">My Kendo UI Button</button>\\n\"","import { NgModule } from '@angular/core';\nimport { Routes, RouterModule } from '@angular/router';\n\nimport { KendoTestingComponent } from './kendo-testing.component';\n\nconst routes: Routes = [{ path: '', component: KendoTestingComponent }];\n\n@NgModule({\n  imports: [RouterModule.forChild(routes)],\n  exports: [RouterModule]\n})\nexport class KendoTestingRoutingModule { }\n","export default \"\\n/*# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsImZpbGUiOiJzcmMvYXBwL2ZlYXR1cmVzL2tlbmRvLXRlc3Rpbmcva2VuZG8tdGVzdGluZy5jb21wb25lbnQuc2NzcyJ9 */\"","import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-kendo-testing',\n  templateUrl: './kendo-testing.component.html',\n  styleUrls: ['./kendo-testing.component.scss']\n})\nexport class KendoTestingComponent {\n    title = 'Hello from the Kendo Testing Component!';\n\n    onButtonClick() {\n        this.title = 'Hello from Kendo UI!';\n    }\n}\n","import { NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { KendoTestingRoutingModule } from './kendo-testing-routing.module';\nimport { KendoTestingComponent } from './kendo-testing.component';\nimport { ButtonsModule } from \"@progress/kendo-angular-buttons\";\n\n\n@NgModule({\n  declarations: [KendoTestingComponent],\n  imports: [\n      CommonModule,\n      ButtonsModule,\n      KendoTestingRoutingModule\n  ]\n})\nexport class KendoTestingModule { }\n"],"sourceRoot":"webpack:///"}